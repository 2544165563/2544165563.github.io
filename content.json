{"meta":{"title":"ScaryPigLX的博客","subtitle":"","description":"chenlvtang友情赞助","author":"liuxiang","url":"http://2544165563.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-05-01T10:18:39.139Z","updated":"2020-05-01T10:18:39.139Z","comments":true,"path":"categories/index.html","permalink":"http://2544165563.github.io/categories/index.html","excerpt":"","text":""},{"title":"[object Object]","date":"2020-04-29T12:57:13.876Z","updated":"2020-04-29T12:57:13.876Z","comments":true,"path":"scaffolds/draft.html","permalink":"http://2544165563.github.io/scaffolds/draft.html","excerpt":"","text":""},{"title":"[object Object]","date":"2020-04-29T12:57:13.878Z","updated":"2020-04-29T12:57:13.878Z","comments":true,"path":"scaffolds/page.html","permalink":"http://2544165563.github.io/scaffolds/page.html","excerpt":"","text":""},{"title":"[object Object]","date":"2020-04-29T12:57:13.881Z","updated":"2020-04-29T12:57:13.881Z","comments":true,"path":"scaffolds/post.html","permalink":"http://2544165563.github.io/scaffolds/post.html","excerpt":"","text":""},{"title":"friends","date":"2020-08-03T15:57:24.527Z","updated":"2020-08-03T15:57:24.527Z","comments":true,"path":"friends/index.html","permalink":"http://2544165563.github.io/friends/index.html","excerpt":"","text":".thick-green-border { border-color: blue; border-style: solid; border-radius:50%; } .ju{ text-align:center;} 1 chenlvtang的小房间 1 由于本人不会插入友链，只能用这个笨方法自己写一个垃圾网页。。 作者：ScaryPigLX 时间：2020-5-2"},{"title":"第一个","date":"2020-04-30T04:50:50.495Z","updated":"2020-04-30T04:50:50.495Z","comments":true,"path":"tags/index.html","permalink":"http://2544165563.github.io/tags/index.html","excerpt":"","text":""},{"title":"打赏","date":"2020-09-17T08:04:22.776Z","updated":"2020-09-17T08:04:22.776Z","comments":true,"path":"打赏/index.html","permalink":"http://2544165563.github.io/%E6%89%93%E8%B5%8F/index.html","excerpt":"","text":""}],"posts":[{"title":"pygame","slug":"pygame","date":"2020-09-14T08:49:47.561Z","updated":"2020-09-19T05:09:43.831Z","comments":true,"path":"2020/09/14/pygame/","link":"","permalink":"http://2544165563.github.io/2020/09/14/pygame/","excerpt":"","text":"1设置屏幕大小 2设置窗口名称 3引入必要图片并为图片设置边框 4设置刷新频率并创建时钟对象 5while循环进行 ​ 5.1设置小球轨迹 ​ 5.2添加图片到窗口 ​ 5.3屏幕刷新 ​ 5.4屏幕刷新延迟 12345678910111213141516171819202122232425262728293031323334353637383940import pygame,syspygame.init() # 初始化屏幕screen = pygame.display.set_mode((600,400),pygame.RESIZABLE) # 设置窗口大小pygame.display.set_caption('游戏进化路') # 窗口名称#pygame.display.set_icon() # 设置图标ball = pygame.image.load('3025.jpg') #引入图片ballrect = ball.get_rect() # 为图片添加边框来定义坐标fps = 300 # 刷新频率fclock = pygame.time.Clock() # 创建时钟对象speed = [1,1] # 小球速度balck = 0,0,0 # 颜色width,height = 600,400 #窗口宽度while True: for event in pygame.event.get(): # 判断事件 if event.type == pygame.QUIT: # 退出 sys.exit() elif event.type == pygame.KEYDOWN: # 移动 if event.key == pygame.K_UP: if speed[0] &gt; 0: speed[0] += 1 print(speed[0]) else: speed[0] -=1 print([speed[0]]) elif event.key == pygame.K_DOWN: if speed[0] &gt; 0: speed[0] -= 1 print(speed[0]) else: speed[0] += 1 print(speed[0]) ballrect = ballrect.move(speed[0],speed[1]) # 移动坐标 if ballrect.left &lt; 0 or ballrect.right &gt; width: # 让小球反弹 speed[0] = -speed[0] if ballrect.top &lt; 0 or ballrect.bottom &gt; height: speed[1] = -speed[1] screen.fill(balck) #设置小球轨迹颜色 screen.blit(ball,ballrect) # 添加图像到屏幕 pygame.display.update() # 屏幕刷新 fclock.tick(fps) # 刷新频率 窗口设置大小123456pygame.display.set_mode((w,h),flags)# flags:pygame.RESIZEBLE 窗口大小可调pygame.NOFRAME 无边界显示pygame.FULLSCREEN 全屏显示 resizeble 123elif event.type == pygame.VIDEORESIZE: # 窗口大小更改事件 size = width,height = event.w,event.h # 获取改变和的size screen = pygame.display.set_mode(size,pygame.RESIZABLE) # 改变游戏大小 fullscreen 123vinfo &#x3D; pygame.display.Info() # 获取当窗口的大小size&#x3D;width,height &#x3D; vinfo.current_w,vinfo.current_h #窗口宽度screen &#x3D; pygame.display.set_mode(size,pygame.FULLSCREEN) # 设置窗口大小 图标、标题123ico &#x3D; pygame.image.load(&#39;图标&#39;)pygame.display.set_icon(ico) 123pygame.display.set_caption('标题')pygame.display.get_caption() # 获取标题 最小化暂停12if pygame.display.get_active(): # 如果窗口最小化，结果为False，图片暂停移动 ballrect = ballrect.move(speed[0],speed[1]) 事件处理鼠标1234567pygame.event.MOUSEMOTION # 鼠标移动event.pos 鼠标当前坐标event.rel 鼠标相对运动距离event.buttons 鼠标三个按键,按下为1,松开为0 12345pygame.event.MOUSEBUTTONUP # 鼠标释放event.posevent.button 三个键，0，1，2 12345pygame.event.MOUSEBUTTONDOWN # 鼠标按下event.posevent.button 左键为1，右键为3","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://2544165563.github.io/tags/python/"}]},{"title":"matplotlib","slug":"matplotlib","date":"2020-09-12T10:34:42.830Z","updated":"2020-09-12T15:19:11.594Z","comments":true,"path":"2020/09/12/matplotlib/","link":"","permalink":"http://2544165563.github.io/2020/09/12/matplotlib/","excerpt":"","text":"12345678910import matplotlib.pyplot as pltplt.subplot(3,2,4) # 分为3个横区，2个竖区，在第2,4,6区内画表plt.plot([2,1,3,4,5],[2,1,3,3,3],[1,2,3,4,5],[2,3,1,3,1])plt.ylabel('test1')plt.subplot(3,2,3)plt.plot([2,3,4,5,1],'r--')plt.ylabel('test2')plt.savefig('test',dpi=1000)plt.axis([0,6,0,6]) # 设置x轴与y轴的范围plt.show() 标签1234567891011plt.xlabel()plt.ylabel()plt.title() # 整体标题plt.text(x,y,'str') # 任意位置添加文本plt.annotate()#plt.annotate('123',xy=(1,2),xytext=(2,3),arrowprops=dict(facecolor='green',shrink=0.2,width=2))#文本，箭头位置，文本位置，箭头颜色，箭头间距，箭头宽度 .plot()123456789101112131415161718tpl.plot(x,y,format_string...)# 颜色 'b' 'g' 'r' 'c'青绿 'm'洋红 'y' 'k' 'w' '0.8'灰度值 '#008000'RGB# 类型'-'实线 '--'破折线 '-.'点画线 ':'虚线 ''''无线条'.'点线 ','小点 'o'大点 'v' '^' '&gt;' '&lt;'各种方向的三角‘1’ ‘2’ ‘3’ ‘4’下上左右花三角‘s’正方形 'p'五角 '*'星形'h'竖六边 'H'横六边 '+' 'x' 'D'菱形 'd'廋菱形 '|' 中文支持方法一默认不支持中文 1234matplotlib.rcParams['font.family']='SimHei' # 黑体#字体类型'SimHei' 'Kaiti' 'LiSu' 'FangSong' 'YouYuan' 'STSong' 其余两个属性 123font.style # 字体类型 normal正常 italic斜体font.size # 字体大小 字号、large、x-small 方法二这个方法比第一个好 1plt.xlabel('横轴',fontproperties='SimHei',fontsize=20) 分区12345678910111213141516# 分区1plt.subplot(3,2,(2,4,6)) # 分为3个横区，2个竖区，在第2,4,6区内画表# 分区2plt.subplot2grid((3,3),(1,0),colspan=2,rowspan=2)#分为3X3的区，选中第2行第1列，并扩展一列和一行# 分区3import matplotlib.gridspec as gdgs = gd.GridSpe(3,3) # 分区a1 = plt.subplot(gs[1,:-1])","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://2544165563.github.io/tags/python/"}]},{"title":"pillow","slug":"pillow","date":"2020-09-06T11:31:18.084Z","updated":"2020-09-06T12:42:13.772Z","comments":true,"path":"2020/09/06/pillow/","link":"","permalink":"http://2544165563.github.io/2020/09/06/pillow/","excerpt":"","text":"颜色反转1234test = np.array(Image.open('路径')) # 路径用/分割test1 = [255,255,255] - testim = Image.fromarray(test1,astype('uint8'))im.save('路径') 灰白123test = np.array(Image.open('路径').convert('L'))test1 = 255-test... 手绘看不懂。。。先弄上 1234567891011121314151617181920212223242526from PIL import Imageimport numpy as np a = np.asarray(Image.open('C:/Users/Administrator/Desktop/我的文件/timg.jpg').convert('L')).astype('float') depth = 10. # (0-100)grad = np.gradient(a) #取图像灰度的梯度值grad_x, grad_y = grad #分别取横纵图像梯度值grad_x = grad_x*depth/100.grad_y = grad_y*depth/100.A = np.sqrt(grad_x**2 + grad_y**2 + 1.)uni_x = grad_x/Auni_y = grad_y/Auni_z = 1./A vec_el = np.pi/2.2 # 光源的俯视角度，弧度值vec_az = np.pi/4. # 光源的方位角度，弧度值dx = np.cos(vec_el)*np.cos(vec_az) #光源对x 轴的影响dy = np.cos(vec_el)*np.sin(vec_az) #光源对y 轴的影响dz = np.sin(vec_el) #光源对z 轴的影响 b = 255*(dx*uni_x + dy*uni_y + dz*uni_z) #光源归一化b = b.clip(0,255) im = Image.fromarray(b.astype('uint8')) #重构图像im.save('C:/Users/Administrator/Desktop/我的文件/test2.jpg')","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://2544165563.github.io/tags/python/"}]},{"title":"NumPy","slug":"NumPy","date":"2020-09-06T01:32:03.675Z","updated":"2020-09-12T14:11:51.108Z","comments":true,"path":"2020/09/06/NumPy/","link":"","permalink":"http://2544165563.github.io/2020/09/06/NumPy/","excerpt":"","text":"ndarray对象属性123456789.ndim # 秩，维度的数量.shape # 尺度，n行m列.size # n*m.dtype # 元素类型.itemsize # 元素的大小 创建123456789np.arrange(n)np.ones((n,m)) # np.ones((n,m),dtype = np.int)np.zeros((n,m)) # 默认是浮点数，和.ones一样np.full((n,m),val) # val为填充字符np.eye(n) # 对角线为1，其余为0的n阶矩阵 12345np.ones_like(a) # 模拟数组a的形状np.zeros_like(a)np.full_like(a,val) 12345np.arange(0,5,1) #根据开始、结束、步数形成数组np.linspace(1,10,4,endpoint=False) # 根据开始、结束、个数形成数组np.concatenate((a,b)) # 合并数组 变换12345678a.reshape((n,m)) # 改变原数组的形状a.resize((n,m)) # 改变形状，原数组a发生改变a.flatten() #降维a.astype(np.int) # 改变元素类型,并创建新的数组 # 直接b=a是指向同一个地址，而b=a.astype()是新的地址 ndarray数组转变成列表类型 1ls = a.tolist() 操作多维数组切片 12345a&#x3D;array([1,2,3], [4,5,6], [7,8,9])a[:,1:2,0:1] #5 统计12345678910111213141516171819202122232425np.sum(a,axis=None) # 和np.mean(a,axis=None) # 期望np.average(a,axis=None,weight=None) # 加权平均值np.std(a,axis=None) # 标准差np.var(a,axis=None) # 方差np.min(a) # 最大值np.max(a) #最小值np.argmin(a) #转一维后的下标np.argmax(a)np.unravel_index(index,shape) #将一维下标转换为多维下标np.ptp(a) # 最大值与最小值的差np.median(a) #计算中位数np.gradient(f) #计算梯度 数据存取一、二维存入 1np.savetxt('a.csv',a,fmt='%.1f',delimiter=',') 取出 1np.loadtxt('a.csv',dtype=np.float,delimiter=',',unpack=False) 多维存入 1a.tofile('b.dat',sep=',',format='%s') # sep为空时以二进制存入 取出 1np.fromfile('b.dat',dtype=float,count=-1,sep=',') 便捷存取123np.save(&#39;b.npy&#39;,b)np.load(&#39;b.npy&#39;) 随机数生产12345678910111213np.random.rank((n,m)) # [0,1)np,random.rankn((n,m)) #正态分布np.random.randint(1,10,(3,3)) #[1,10)np.random.seek(d) #指定一个种子，使随机数结果确定np.random.uniform(1,10,(n,m)) #均匀分布np.random.normal(均值,标准差,(m,n)) #正态分布np.random.poisson(发生率,(m,naxis)) #泊松分布 改变12345np.random.shuffle(a) # 对最外层随机排列，改变数组anp.random.permutation(a) #不对a改变np.chioce(a,10,replace=False) #在a中选取10个，不可重复","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://2544165563.github.io/tags/python/"}]},{"title":"mysql基础","slug":"mysql基础","date":"2020-09-03T13:27:58.306Z","updated":"2020-10-03T03:32:55.884Z","comments":true,"path":"2020/09/03/mysql基础/","link":"","permalink":"http://2544165563.github.io/2020/09/03/mysql%E5%9F%BA%E7%A1%80/","excerpt":"","text":"创建数据库1create database pig; 展示数据库 1show databases; 使用该数据库 1use &lt;库名&gt; 表展示该数据库中的所有表 1show tables; 显示表的详情信息 1describe &lt;表名&gt; 创建表12345678910create table tb( id int auto_increment not null primary key, name varchar(10) not null default 1, password varchar(10) not null, sex int not null check(sex in [1,2]) ); 创建外键与主键12345678create table test2(学号 char(4) not null, 姓名 char(4) not null, primary key(学号), foreign key(学号) references test1(学号) on delete restrict on update cascade); 123456789restrict 拒绝操作cascade 级联操作no action 不执行操作set default 设为默认值set null 设为空值 check、枚举类型enum123456create table test(性别 char(1) not null check(性别 in (&#39;男&#39;,&#39;女&#39;)));# 好像mysql中check不起作用。。。create table test(性别 enum(&#39;男&#39;,&#39;女&#39;) not null); 完整性约束创建 123create table test(姓名 char(4) not null,constraint primary_key primary key(姓名)); 删除 1alter table test drop primary key; 修改表1234567891011alter table &lt;表名&gt; add column &lt;列名&gt; &lt;类型&gt; .. # 添加列alter table &lt;表名&gt; motify &lt;列名&gt; &lt;类型&gt; .. # 更改列的属性alter table &lt;表名&gt; drop column &lt;列名&gt; # 删除列alter table &lt;表名&gt; rename &lt;新表名&gt; # 修改表名alter table &lt;表名&gt; change &lt;列名&gt; &lt;原列名&gt; # 修改列名，但我运行失败了drop table if exists &lt;表名&gt; # 删除表 插入insert 1insert into &lt;表名&gt; values (&lt;&gt;,&lt;&gt;,&lt;&gt;); replace 与insert功能相同，不过能替代原有的数据 1replace into &lt;表名&gt; vales (&lt;&gt;,&lt;&gt;,&lt;&gt;); 更改1update &lt;表名&gt; set &lt;改动&gt;; 查找1select * from Student; 列名更换 1select sname 姓名 from Student # 将列名sname更换成&#39;姓名&#39;输出; between 1select * from Student where Sage between 10 and 20; in 1select * from Student where Sno in (1,2,3); % _ / 123select * from Student where Sname like &#39;刘%&#39; # %任意数量字符,_单个字符;select * from Student where Sname like &#39;刘\\_,escape&#39;\\&#39;; is 1select * from Student where Sname is not null; order by 1select * from Student order by Sno desc; # desc降序,asc升序 聚合函数 1select count(*) from Student; # sum,avg,max,min group by 1select 课程号,count(学号) from xs_kc group by 课程号 having count(学号)&lt;2; 内连接与外连接12345select * from A inner join B on A.name&#x3D;B.name;select * from A left&#x2F;right outer join B on A.name&#x3D;B.namemysql不支持full outer join。。。 删除删除表 1drop &lt;表名&gt; 删除数据 1delete from &lt;表名&gt; where &lt;条件&gt;; 视图创建视图12create view avg(num,avg) asselect 学号,avg(成绩) from xs_kc group by 学号 having avg(成绩)&gt;80 with check option; 123cteate view test as select * from xs where 专业名&#x3D;&#39;计算机&#39; with chexk option;with check option 在更新视图的时候判断是否符合where语句 修改视图1alter view test as select 学号,姓名,总学分 from xs where 专业名&#x3D;&#39;计算机&#39;","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://2544165563.github.io/tags/mysql/"}]},{"title":"Linux基础","slug":"Linux基础","date":"2020-09-01T13:27:33.996Z","updated":"2020-09-28T13:51:04.023Z","comments":true,"path":"2020/09/01/Linux基础/","link":"","permalink":"http://2544165563.github.io/2020/09/01/Linux%E5%9F%BA%E7%A1%80/","excerpt":"","text":"通配符123456789101112131415161718192021* 任意长度的任意字符? 单个任意字符[] 范围内的字符,如[a-z,0-9][a-z] 除了大Z外的其他字母[A-Z] 除了小a外的其他字母[:upper:] 全大写字母[:lower:] 全小写[:alpha:] 全部大小写[:digit:] 全部数字[:alnum:] 全部数字+字母[^0-9] 0-9范围内的其他数值 转义序列1234567891011\\n\\b 退格\\c 不打印换行\\f 换页\\a 警报(就是运行时嘀~一声)\\r 回车 ll结果分析123456789101112一 二 三 四 五 六 七 八 十 - rw- r-- r-- 1 root root 656 9月 9 06:38 一 &#39;-&#39;表文件,&#39;d&#39;表目录二 当前用户权限，r读,w写,x执行三 当前组用户权限四 其他组权限五 文件被调用次数六 所有者七 所在组八 文件大小十 最后修改时间 界面的切换1234先打开命令行登录init 3 切换到命令行界面init 5 切换成图形界面 基础指令history 历史记录12345history 查看指令历史记录history 10 显示最近10条记录!&lt;记录序号&gt; 使用该记录的代码 help 帮助123help 命令 用于内部命令命令 --help 用于外部命令 man 详细帮助12345man 命令&#x2F; 查找字符串q 退出手册 info 超详细目录1info 命令 与man功能差不多，但查找到的东西更多 init123456789101112130 停机1 单用户2 多用户，没有NFS，不联网3 完全多用户4 没用5 图形化界面6 重启 paweroff普通用户和管理员都可以用，如果多个用户用该系统，则普通用户也不能用 123-w 不会关机,把记录写在&#x2F;var&#x2F;log&#x2F;wtmp里-d 与w相反,关机不写 shutdown只有管理员能够使用 1234567891011shutdown 5 byebye-t 设定几秒后关机-k 不会真关机，只会警告使用者-r 关机后重启-n 强制杀掉程序关机-c 取消进行中的关机动作 halt不会关闭电源 1234567-w 不关机，写记录&#x2F;var&#x2F;log&#x2F;wtmp-f 强制关机,不呼叫shutdown-d 不写记录关机-p 关机的时候关闭电源(poweroff) reboot12345-w-d-f logname初次登陆的用户 whoami当前活动用户 who详情版users 当前登录系统的用户列表 users当前登录系统的用户列表 id查看用户的详细信息 last登录系统的历史信息 123-num 展示前num个username 展示username的登入信息 uname显示计算机的基本信息 hostname显示计算机名称 1hostname XXX 暂时更改主机名 hostnamectl永久设置主机名称 123hostnamectl status 查看当前主机名设置hostnamectl set-hostname XXX useradd/etc/passwd 存放用户信息 12345678910111213-d 指定用户的登入目录-e 账户有效天数-f 账号过期多少天后关闭-r 建立系统账号-g 指定所属群组-G 所属附加群组-u 指定用户ID usermod修改用户 12345-l 修改用户名-L 锁定账号密码-U 解除密码锁定 userdel1-r 删除用户登入目录 su12345su test 切换到testsu - test 切换到test且当前路径改为test的homesu -c ls root 借用root的权限 groupadd/etc/group 存放组的信息 123-g 指定组的id-r 使组的id小于500 groupmod1-n &lt;new_name&gt; &lt;old_name&gt; 设置新的组名 groupdelcd 切换目录12345cd .. 回到父目录cd - 回到上一个目录cd ~ 回到家目录 pwd 查看当前目录cat1234567-n # 给每行加上序号，包括空格-b # 加序号，不包括空格-s # 将一行以上的空行转换为一行cat -n test1 &gt; test2 # 将test1文本加上序号后复制test2 moreenter 下一行 f 空格 下一屏 b 上一屏 12345-s # 将一行以上的空行转换为一行more +10 test # 在第10行开始显示more -3 test # 每次显示3行 ls12345678910111213ls -a 显示所有文件和目录ls -d 只显示目录ls -l 文件详情信息ls -r 反次序显示ls -t 按建立时间列出ls -A 同a，不列出.与..ls -R 显示所有文件包括目录里的 mkdir 创建目录123456789mkdir &lt;选项&gt; &lt;目录名&gt;mkdir &#123;user1,user2,user3&#125; 创建多个目录mkdir -m &lt;权限&gt; &lt;目录名&gt; 创建权限目录 mkdir -v &lt;目录名&gt; 创建并显示信息mkdir -p test1&#x2F;test1.1 创建目录及子目录 rmdir 删除目录123rmdir -p test1&#x2F;test1.1rmdir -v 显示指令执行过程 touch 创建文件123touch &#123;t1,t2&#125;.mp4touch -c &lt;文件名&gt; 更改访问时间 cp 复制文件或目录123456789cp &lt;文件&gt; &lt;指令&gt; &lt;指定目录&gt; -p 保持原属性不变 -r 递归复制目录下所有文件 -f 强制复制，直接覆盖重名 -l 不复制，只生产链接文件 mv 移动文件、改名123456789mv &lt;选项&gt; &lt;源文件&gt; &lt;指定目录&gt;mv &lt;old_name&gt; &lt;new_name&gt; -b 若覆盖，先备份 -f 直接覆盖 -u 若源文件较新，就更新目标文件 rm 删除文件12345rm &lt;选项&gt; &lt;文件名&gt; -f 强行删除 -r 删除目录及文件 ln链接123456789101112131415ln &lt;选项&gt; &lt;文件&gt; &lt;目标&#x2F;new_name&gt;-b 删除,覆盖以前建的链接-d 允许超级用户制作目录的硬链接-f-i-v 显示处理过程-n 把符号链接视为一般目录(老师说这话是硬链接0.0)-s 软链接(符号链接) find 查找文件12345678910111213find 路径 &lt;选项&gt; &lt;文件名&gt; -name 区分大小写 -iname 不区分大小写 -size -10M 小于10M的文件 -type 类型 -user 所属用户 -group 所属组 vi 编辑1234567891011121314151617vi &lt;文档&gt;i 当前位置字符前插入a 当前位置字符后插入c 好像是清空再插入o 当前位置的下一行开始插入p 将最后一个删除文本放在当前字符:w! 强制保存:q! 强制退出:e! 放弃所有修改，重上次保存开始再编辑 echo默认输出后换行 1234567echo &quot;string&quot;echo &#96;date&#96; 不是单引号，是反引号-e 识别转义符-n 输出后不换行 printf输出默认输出后不换行 123printf &quot;this is string&quot; 无双引号，单引号都可printf &quot;this is %s\\n&quot; &quot;sting&quot; 在不带引号的时候要\\\\n才能换行 date123456789date &#39;+%D&#39;%D 09&#x2F;26&#x2F;20%x 09&#x2F;26&#x2F;2020%T 23:10:31%X 23:10:31 PM cal日历1234567cal 2020-y 当年日历-3 上个月，这月，下月-j 某一日位于当年的第几天 expr计数器123456789expr 2 + 5 # 7expr 2+5 # 2+5expr length &quot;this&quot; # 4expr substr &quot;this is a test&quot; 3 5 # is is 在第3个字符开始,抓取5个字符expr index &quot;123456&quot; 5 # 5 抓取该字符第一次出现的位置 软链接与硬链接区别软链接1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接硬链接：1.硬链接以文件副本的形式存在。但不占用实际空间。2.不允许给目录创建硬链接3.硬链接只有在同一个文件系统中才能创建 软链接de特征1.软链接有自己的文件属性及权限等；2.可对不存在的文件或目录创建软链接；3.软链接可交叉文件系统；4.软链接可对文件或目录创建；5.创建软链接时，链接计数 i_nlink 不会增加；6.删除软链接并不影响被指向的文件,但若被指向的原文件被删除，则相关软连接被称为死链接 (即 dangling link,若被指向路径文件被重新创建,死链接可恢复为正常的软链接）。 root密码修改在系统内修改密码 1passwd 在系统外修改密码 1不会进入单用户模式。。。以后再弄吧","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://2544165563.github.io/tags/Linux/"}]},{"title":"高数（大一）","slug":"高数（大一）","date":"2020-08-27T03:00:50.646Z","updated":"2020-07-15T06:55:22.357Z","comments":true,"path":"2020/08/27/高数（大一）/","link":"","permalink":"http://2544165563.github.io/2020/08/27/%E9%AB%98%E6%95%B0%EF%BC%88%E5%A4%A7%E4%B8%80%EF%BC%89/","excerpt":"定积分","text":"定积分 积分上限函数格式： 积分上限函数的导数： 例题： 定积分的计算牛顿莱布尼茨公式（基本公式）求导公式，arcsinx 构造法，分子-1+1 换元法三角换元 第一类换元 第二类换元 分部积分法 反常积分无穷区间上的反常积分定义： 收敛与发散 无界函数的反常积分定义： 收敛和发散： 定积分的几何应用曲线的长度! 例题： 平面图形的面积直角坐标 极坐标 旋转体的体积 微分方程普通微分方程 定义：几阶导数就是几阶微分方程 例题：验证某函数是否是微分方程的解 可分离变量的微分方程 齐次方程格式： 解法： 一阶线性方程格式： Q(x)=0为齐次方程，否则为非齐次方程 解法：将非齐次或为齐次，求得： 原非齐次方程的通解为： 伯努利方程 格式： 解法： 证明解的例题： 高阶微分方程1.自变量只有x直接连续积分。 2.变量为x、y的导数 3.变量为y、y的导数 偏导数偏导数存在，但不一定连续 例子： 高阶偏导数 全微分 全微分的近似计算 多元复合函数求导法则： 例题： 隐函数一个方程 方程组 求极值步骤 1.分别对x,y求导得出Fx,Fy,求出驻点 2.分别求A:Fxx,B:Fxy,C:Fyy。 3.求出AC-B²。 4.将驻点带入，如果&gt;0，则是极值点。 重积分重积分的计算性质： 1.公式相加性 2.区域相加性 3.公式比较，公式大的二重积分也大 4.对称性 解决方法： 1.利用直角坐标 X-型区域、Y-型区域 例题： 2.利用极坐标 例题： 重积分x、y型的转换（空） 无穷级数绝对收敛和条件收敛绝对收敛：将通项加上绝对值后仍然收敛。 条件收敛：通项加绝对值不收敛，不加绝对值收敛。 常数项级数解决方法： 1.如果是两项相减，直接带入前几项求 2.当一般项为等比数列时，当|q|&lt;1时收敛，当|q|&gt;=1时发散 3.裂项法 4.比较审敛法:大收敛小的就收敛，小的发散大的就发散 5.比值审敛法 6.根植审敛法（柯西判别法） 7.极限审敛法 交错级数绝对收敛：加了绝对值符号依旧收敛。 条件收敛：去了绝对值符号才收敛。 1.一般项极限为0，前一项大于后一项 幂级数 收敛区间与收敛域的区别收敛区间：小于收敛半径的开区间 收敛域：将区间的两个值带入原幂函数，判断是收敛还是发散，如果收敛则为闭区间","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"高数","slug":"高数","permalink":"http://2544165563.github.io/tags/%E9%AB%98%E6%95%B0/"}]},{"title":"JAVA登录小程序","slug":"该死的苍蝇（附JAVAGUI连接数据库代码）","date":"2020-08-27T03:00:50.644Z","updated":"2020-08-01T02:07:39.859Z","comments":true,"path":"2020/08/27/该死的苍蝇（附JAVAGUI连接数据库代码）/","link":"","permalink":"http://2544165563.github.io/2020/08/27/%E8%AF%A5%E6%AD%BB%E7%9A%84%E8%8B%8D%E8%9D%87%EF%BC%88%E9%99%84JAVAGUI%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A3%E7%A0%81%EF%BC%89/","excerpt":"该死的苍蝇🐸。","text":"该死的苍蝇🐸。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.io.*;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class Action extends JFrame implements ActionListener&#123; public Action() &#123; init(); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#125; JButton button,button1; JTextField text1; JPasswordField text2; Box basebox,box1,box2; Connection con; String sql,s1,s2; void init() &#123; setLayout(new FlowLayout()); JTextArea area=new JTextArea(20,20); JPanel panel=new JPanel(); text1=new JTextField(10); //定义事件源text2=new JPasswordField(10);button=new JButton(\"登录\");button1=new JButton(\"注册\"); text1.addActionListener(this);//注册监视器 text2.addActionListener(this); button.addActionListener(this); button1.addActionListener(this);box1=Box.createVerticalBox(); //布局box1.add(new JLabel(\"用户名：\"));box1.add(Box.createVerticalStrut(8));box1.add(new JLabel(\"密码：\"));box1.add(Box.createVerticalStrut(8));box2=Box.createVerticalBox();box2.add(text1);box2.add(Box.createVerticalStrut(8));box2.add(text2);box2.add(Box.createVerticalStrut(8));basebox=Box.createHorizontalBox();basebox.add(box1);basebox.add(Box.createHorizontalStrut(10));basebox.add(box2);add(basebox);panel.add(button);panel.add(button1);add(panel);add(area);try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); area.append(\"加载数据库驱动成功\\n\");&#125; catch (ClassNotFoundException e) &#123; area.append(\"加载数据库驱动失败\\n\");&#125;try &#123; con=DriverManager.getConnection(\"jdbc:mysql://localhost:3306/date1\",\"root\",\"liuxiang5.\"); area.append(\"连接数据库成功\");&#125; catch (SQLException e) &#123; area.append(\"连接数据库失败\");&#125; &#125; public void actionPerformed(ActionEvent e) &#123; //重写抽象方法 if(e.getSource()==button) &#123; s1=text1.getText().trim(); s2=text2.getText().trim(); sql=\"select * from account where password='\"+s1+\"' and password='\"+s2+\"'\"; try &#123; Statement st=con.createStatement(); ResultSet rs=st.executeQuery(sql); if(rs.next()) &#123; JOptionPane.showMessageDialog(button, \"登录成功\"); text1.setText(null); text2.setText(null);&#125; else JOptionPane.showMessageDialog(button, \"登陆失败\"); &#125; catch (SQLException e1) &#123; JOptionPane.showMessageDialog(button, \"登陆失败\"); text1.setText(null); text2.setText(null); &#125;&#125; else if(e.getSource()==button1)&#123; sql=\"insert into account values('\"+s1+\"','\"+s2+\"')\"; try &#123; PreparedStatement pst; pst=con.prepareStatement(sql); int m=pst.executeUpdate(); if(m&gt;0) &#123; JOptionPane.showMessageDialog(button1, \"注册成功\"); text1.setText(null); text2.setText(null); &#125; &#125; catch (SQLException e1) &#123; JOptionPane.showMessageDialog(button1, \"注册失败\"); text1.setText(null); text2.setText(null); &#125; &#125; &#125; &#125;public class Test &#123; public static void main(String[] args) &#123;Action win=new Action(); win.setBounds(100, 100, 310, 260); win.setTitle(\"登录窗口\");&#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://2544165563.github.io/tags/JAVA/"}]},{"title":"泛型与集合框架","slug":"泛型与集合框架","date":"2020-08-27T03:00:50.643Z","updated":"2020-07-15T06:55:32.580Z","comments":true,"path":"2020/08/27/泛型与集合框架/","link":"","permalink":"http://2544165563.github.io/2020/08/27/%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"1.List表(有序可重复)(LinkedList链表、ArrayList)","text":"1.List表(有序可重复)(LinkedList链表、ArrayList) 常用方法： void add(int index,Object element) boolean addAll(int index,Collection c) Object get(int index) Object remove(int index) Object set(int index,Object element) int indexOf(Object o) int lastIndex(Object o) List subList(int fromIndex,int toIndex) 1234567891011121314151617181920212223242526272829public class Man &#123;String name;int age;int wages;Man(String name,int age,int wages) &#123; this.name=name; this.age=age; this.wages=wages;&#125;void get() &#123; System.out.println(\"姓名:\"+name+\" \"+\"年龄:\"+age+\" \"+\"工资:\"+wages);;&#125;&#125;/*---------------------------------------------------------------------------------*/import java.util.*;public class And&#123; public static void main(String[] args)&#123; List&lt;Man&gt; list=new ArrayList&lt;&gt;(); //&lt;泛型&gt; list.add(new Man(\"张三\", 18, 3000)); list.add(new Man(\"李四\", 25, 3500)); list.add(new Man(\"王五\", 22, 3200)); list.add(new Man(\"赵六\", 24, 3300)); int len=list.size(); //获取长度//迭代器遍历Iterator&lt;Man&gt; iterator=list.iterator(); while(iterator.hasNext()) &#123; Man man=iterator.next(); man.get();&#125;&#125;&#125;//简单遍历for(Man man : list) &#123; man.get();&#125; &#125;&#125; (1)Stack栈常用方法： Object push(Object item) Object pop() boolean empty() //判断是否为空 12345678910import java.util.*;public class And&#123; static String months[]= &#123;\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"&#125;; public static void main(String[] args)&#123; Stack&lt;String&gt; stk=new Stack&lt;&gt;(); for(int i=0;i&lt;months.length;i++) stk.push(months[i]); System.out.println(stk); //输出栈内元素（正序） while(!stk.empty()) System.out.println(stk.pop());&#125;&#125; //出栈（倒序） (2)Queue队列常用方法1.抛出异常方法 add(e) remove() element() ​ 2.返回元素方法 offer(e) poll() peek() 123456789import java.util.*;public class And&#123; static String months[]= &#123;\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"&#125;; public static void main(String[] args)&#123; Queue&lt;String&gt; que=new LinkedList&lt;&gt;(); for(int i=0;i&lt;months.length;i++) que.offer(months[i]); while(!que.isEmpty()) System.out.println(que.poll());&#125;&#125; 2.Set集(无序不可重复)(HashSet、TreeSet树集)123456789import java.util.*;public class And&#123; public static void main(String[] args)&#123; Set&lt;String&gt; set=new TreeSet&lt;&gt;(); set.add(\"apple\"); set.add(\"banane\"); set.add(\"apple\");System.out.println(set.contains(\"banane\")); //判断是否存在 System.out.println(set); &#125;&#125; 输出结果： ​ true ​ [apple,banane] 3.Map映射（键-值对的集合）（HashMap散列映射、TreeMap）常用方法：put(key,value) get(key) ​ entrySet(） keySet() values() 1234567891011121314151617import java.util.*;public class And&#123; public static void main(String[] args)&#123; Map&lt;String,String&gt; map=new TreeMap&lt;&gt;(); map.put(\"1\", \"apple\"); map.put(\"2\", \"banane\"); map.put(\"1\", \"orange\"); System.out.println(map.get(\"1\")); for(String s:map.keySet()) //根据键输出值 System.out.print(map.get(s)+\" \");System.out.print(\"\\n\"); for(String s:map.values()) //直接输出值 System.out.print(s+\" \");System.out.print(\"\\n\"); Iterator it=map.entrySet().iterator(); //迭代器遍历 while(it.hasNext()) &#123; Map.Entry&lt;String,String&gt; entry=(Map.Entry&lt;String, String&gt;)it.next(); System.out.println(entry.getKey()+\":\"+entry.getValue());&#125; &#125;&#125; 输出结果： ​ orange ​ orange banane ​ orange banane ​ 1:orange ​ 2:banane 4.泛型优点：可以建立具有类型安全的数据结构，在使用泛型类建立的数据结构时，不必进行类型转换 泛型类： class ShowObject E为任何对象（类）或接口 ​ 泛型变量只能调用toString方法 泛型类声明对象：泛型类声明和创建对象时，类名后多一对“&lt;&gt;”","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://2544165563.github.io/tags/JAVA/"}]},{"title":"菜鸡的无聊代码","slug":"菜鸡的无聊代码","date":"2020-08-27T03:00:50.643Z","updated":"2020-07-15T06:55:28.663Z","comments":true,"path":"2020/08/27/菜鸡的无聊代码/","link":"","permalink":"http://2544165563.github.io/2020/08/27/%E8%8F%9C%E9%B8%A1%E7%9A%84%E6%97%A0%E8%81%8A%E4%BB%A3%E7%A0%81/","excerpt":"又不想学习，游戏又没新玩法，闲的用刚学的知识写几行代🦓🐴🦄，欢迎尝试运行下👀","text":"又不想学习，游戏又没新玩法，闲的用刚学的知识写几行代🦓🐴🦄，欢迎尝试运行下👀 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import javax.swing.*;import java.awt.*;import java.awt.event.*;public class Action extends JFrame implements WindowListener,ActionListener,MouseListener&#123;JButton button1,button2;public Action() &#123; init(); setVisible(true); setDefaultCloseOperation(JFrame.DEFAULT_CURSOR); this.addWindowListener(this); &#125;void init() &#123; setLayout(new FlowLayout(FlowLayout.CENTER,200,40)); JLabel label=new JLabel(\"你是憨憨吗？\"); label.setFont(new Font(\"宋体\",Font.PLAIN,100)); button1=new JButton(\"我是\"); button2=new JButton(\"我不是\"); button1.addActionListener(this); button2.addActionListener(this); button2.addMouseListener(this); JPanel panel=new JPanel(); JPanel panel2=new JPanel(); panel.add(label); add(panel); add(button1); add(button2);&#125;@Overridepublic void windowActivated(WindowEvent e) &#123;&#125;@Overridepublic void windowClosed(WindowEvent e) &#123;&#125;@Overridepublic void windowClosing(WindowEvent e) &#123; int a=JOptionPane.showConfirmDialog(null, \"你是一个憨憨吗\",\"询问\",JOptionPane.YES_NO_OPTION); if(a==JOptionPane.YES_OPTION) System.exit(-1);&#125;@Overridepublic void windowDeactivated(WindowEvent e) &#123; &#125;@Overridepublic void windowDeiconified(WindowEvent e) &#123;&#125;@Overridepublic void windowIconified(WindowEvent e) &#123;&#125;@Overridepublic void windowOpened(WindowEvent e) &#123; &#125;@Overridepublic void actionPerformed(ActionEvent e) &#123; if(e.getSource().equals(button1)) &#123; JOptionPane.showMessageDialog(this, \"有自知之明，不错。\",\"恭喜\",JOptionPane.PLAIN_MESSAGE); &#125; else if(e.getSource().equals(button2))&#123; JOptionPane.showMessageDialog(this, \"你竟然！！！\",\"可怕\",JOptionPane.INFORMATION_MESSAGE); &#125; &#125;@Overridepublic void mouseClicked(MouseEvent e) &#123;&#125;@Overridepublic void mouseEntered(MouseEvent e) &#123; Component com=null; if(e.getSource() instanceof Component) &#123; com=(Component) e.getSource(); int a=(int) (1+Math.random()*800); int b=(int) (1+Math.random()*800); com.setLocation(a,b); &#125; &#125;@Overridepublic void mouseExited(MouseEvent arg0) &#123; // TODO Auto-generated method stub &#125;@Overridepublic void mousePressed(MouseEvent arg0) &#123; // TODO Auto-generated method stub &#125;@Overridepublic void mouseReleased(MouseEvent arg0) &#123; // TODO Auto-generated method stub &#125;&#125;public class Test &#123; public static void main(String[] args) &#123;Action win=new Action(); win.setBounds(0, 0, 960, 960); win.setTitle(\"真诚的问题\");&#125;&#125;","categories":[{"name":"日常","slug":"日常","permalink":"http://2544165563.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://2544165563.github.io/tags/JAVA/"}]},{"title":"图形用户界面设计","slug":"图形用户界面设计","date":"2020-08-27T03:00:50.641Z","updated":"2020-07-15T06:55:39.986Z","comments":true,"path":"2020/08/27/图形用户界面设计/","link":"","permalink":"http://2544165563.github.io/2020/08/27/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/","excerpt":"1.窗口(JFrame)","text":"1.窗口(JFrame) 12345678910111213import static javax.swing.JFrame.*;import javax.swing.*;public class Test &#123; public static void main(String[] args) &#123; JFrame window1=new JFrame(\"我的世界\"); //创建 JFrame window2=new JFrame(\"星际战甲\"); window1.setBounds(60, 100, 1588, 980); //调整（前部分为位置x,y，后面为大小w,h） window2.setBounds(260, 100, 588, 308); window1.setVisible(true); //是否显示窗口 window1.setDefaultCloseOperation(EXIT_ON_CLOSE); //点击关闭图标时的处理 window2.setVisible(true); window2.setDefaultCloseOperation(DISPOSE_ON_CLOSE); &#125;&#125; 2.菜单条(JMenubar)、菜单(JMenu)、菜单项(JMenuItem)1234567891011121314151617181920212223242526272829303132import javax.swing.*;import java.awt.event.InputEvent;import java.awt.event.KeyEvent;import static javax.swing.JFrame.*;public class WindowMenu extends JFrame &#123; public WindowMenu() &#123;&#125; public WindowMenu(String s,int x,int y,int w,int h) &#123; init(s); setLocation(x, y); setSize(w, h); setVisible(true); setDefaultCloseOperation(DISPOSE_ON_CLOSE); &#125; void init(String s) &#123; setTitle(s); JMenuBar menubar =new JMenuBar(); //建立菜单条 JMenu menu=new JMenu(\"菜单\"); //建立菜单 JMenu submenu=new JMenu(\"软件项目\"); JMenuItem item1=new JMenuItem(\"JAVA话题\",new ImageIcon(\"a.gif\")); JMenuItem item2=new JMenuItem(\"动画话题\",new ImageIcon(\"b.gif\")); menu.add(item1); menu.addSeparator(); menu.add(item2); menu.add(submenu); submenu.add(new JMenuItem(\"汽车销售系统\",new ImageIcon(\"c.gif\"))); submenu.add(new JMenuItem(\"农场信息系统\",new ImageIcon(\"d.gif\"))); menubar.add(menu); setJMenuBar(menubar); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123;WindowMenu win=new WindowMenu(\"我的世界\",20,30,1200,900); &#125;&#125; 3.常用组件与布局组件： 1.文本框(JTextField） 12345void init() &#123; setLayout(new FlowLayout(); add(new JLabel(\"文本框\")); JTextField text=new JTextField(10);add(text);&#125; 2.文本区(JTexArea) 123add(new JLabel(\"文本区\"));JTextArea texts=new JTextArea(6,12);add(new JScrollPane(texts)); //滚动窗格 3.按钮(JButton) 123add(new JLabel(\"按钮:\"));JButton button=new JButton(\"确定\");add(button); 4.标签(JLabel) 1add(new JLabel(\"名称\")); 5.选择框(JCheckBox) 1234567add(new JLabel(\"选择框\")); JCheckBox check1=new JCheckBox(\"篮球\"); JCheckBox check2=new JCheckBox(\"足球\"); JCheckBox check3=new JCheckBox(\"乒乓球\"); add(check1); add(check2); add(check3); 6.单选按钮(JRadioButton) 12345678add(new JLabel(\"单选按钮\")); ButtonGroup group=new ButtonGroup(); JRadioButton radio1=new JRadioButton(\"男\"); JRadioButton radio2=new JRadioButton(\"女\"); group.add(radio1); group.add(radio2); add(radio1); add(radio2); 7.下拉列表(JComboBox) 123456add(new JLabel(\"下拉列表\")); JComboBox combox=new JComboBox(); combox.addItem(\"星际战甲\"); combox.addItem(\"英雄联盟\"); combox.addItem(\"我的世界\"); add(combox); 8.密码框(JPasswordField) 1234add(new JLabel(\"密码框\"));JPasswordField password=new JPasswordField(10);password.setEchoChar('*');add(password); 9.面板(JPanel) 三种常用布局： 1.FlowLayout流动式布局 12setLayout(new FlowLayout(FlowLayout.CENTER，20，40)); //创建布局，中间对齐，水平间距，竖直间距。（默认是中，5，5） 2.BorderLayout边框式布局 123456789101112131415161718 void init() &#123; setLayout(new BorderLayout()); //创建布局 JButton button=new JButton(\"确1定\"); add(button,BorderLayout.SOUTH); JButton button1=new JButton(\"确2定\"); add(button1,BorderLayout.CENTER); JButton button2=new JButton(\"确3定\"); add(button2,BorderLayout.WEST); JButton button3=new JButton(\"确4定\"); add(button3,BorderLayout.EAST); add(new JButton(\"确5定\"),BorderLayout.NORTH);&#125; 3.GridLayout网格式布局 12void init() &#123;setLayout(new GridLayout(2,2)); //2行2列 1234567891011JButton button=new JButton(\"确1定\");add(button);JButton button1=new JButton(\"确2定\");add(button1);JButton button2=new JButton(\"确3定\");add(button2);JButton button3=new JButton(\"确4定\");add(button3,BorderLayout.EAST); &#125; 混合使用 1234567891011121314151617 void init() &#123; JLabel label=new JLabel(\"标签\"); JPanel panel=new JPanel(); panel.setLayout(new GridLayout(2,2)); //创建布局JButton button=new JButton(\"确1定\");panel.add(button);JButton button1=new JButton(\"确2定\");panel.add(button1);JButton button2=new JButton(\"确3定\");panel.add(button2);JButton button3=new JButton(\"确4定\"); panel.add(button3); add(label,BorderLayout.NORTH); add(panel,BorderLayout.SOUTH); &#125; 4.处理事件1.ActionEvent事件（文本框、按钮、菜单项、密码框、单选按钮）setText()设置内容 getText()获得内容 append() 添加内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.io.*;public class Action extends JFrame implements ActionListener&#123; public Action() &#123; init(); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#125; JButton button,button1; JTextField text1; JPasswordField text2; Box basebox,box1,box2; void init() &#123; setLayout(new FlowLayout()); JPanel panel=new JPanel(); text1=new JTextField(10); //定义事件源text2=new JPasswordField(10);button=new JButton(\"登录\");button1=new JButton(\"清空\"); text1.addActionListener(this);//注册监视器 text2.addActionListener(this); button.addActionListener(this); button1.addActionListener(this);box1=Box.createVerticalBox(); //布局box1.add(new JLabel(\"用户名：\"));box1.add(Box.createVerticalStrut(8));box1.add(new JLabel(\"密码：\"));box1.add(Box.createVerticalStrut(8));box2=Box.createVerticalBox();box2.add(text1);box2.add(Box.createVerticalStrut(8));box2.add(text2);box2.add(Box.createVerticalStrut(8));basebox=Box.createHorizontalBox();basebox.add(box1);basebox.add(Box.createHorizontalStrut(10));basebox.add(box2);add(basebox);panel.add(button);panel.add(button1);add(panel);&#125; public void actionPerformed(ActionEvent e) &#123; //重写抽象方法 if(e.getSource()==button) &#123; String s1=text1.getText(); String s2=text2.getText(); String s3=\"123456\"; String s4=\"admin\"; if(s1.matches(s4)&amp;&amp;s2.matches(s3)) JOptionPane.showMessageDialog(this, \"密码正确\"); else &#123;JOptionPane.showMessageDialog(this, \"密码错误\");&#125; //弹出对话框 &#125; else &#123;text1.setText(null); text2.setText(null);&#125; &#125; &#125;public class Test &#123; public static void main(String[] args) &#123;Action win=new Action(); win.setBounds(100, 100, 310, 260); win.setTitle(\"登录窗口\");&#125;&#125; 2.ItemEvent事件（下拉列表、选择框）getItemSelectable()返回事件源 12345678910111213141516171819202122232425262728293031323334353637import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.io.*;public class Action extends JFrame implements ItemListener&#123;JComboBox chioce;JTextArea textshow;public Action() &#123; init(); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#125;void init() &#123; setLayout(new FlowLayout()); chioce=new JComboBox(); chioce.addItem(\"请做出你的选择\"); chioce.addItem(\"星际战甲\"); chioce.addItem(\"我的世界\"); chioce.addItem(\"英雄联盟\"); JButton button=new JButton(\"选择\"); chioce.addItemListener(this); textshow=new JTextArea(9,20); //高，宽 add(chioce); add(button); add(new JScrollPane(textshow));&#125;public void itemStateChanged(ItemEvent e) &#123; if(chioce.getSelectedItem().equals(\"星际战甲\")) textshow.setText(\"我喜欢\"); else if(chioce.getSelectedItem().equals(\"我的世界\"))textshow.setText(\"怀念\"); else textshow.setText(\"无限火力！！！\"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123;Action win=new Action(); win.setBounds(100, 100, 310, 260); win.setTitle(\"登录窗口\");&#125;&#125; 3.DocumentEvent事件（文本区）getDocument()返回文档事件源，注册监视器的时候用 12345678910111213141516171819202122232425262728293031323334353637383940import javax.swing.*;import javax.swing.event.DocumentEvent;import javax.swing.event.DocumentListener;import java.awt.*;import java.awt.event.*;import java.io.*;import java.util.Arrays;public class Action extends JFrame implements DocumentListener&#123;JTextArea text1,text2;public Action() &#123; init(); setLayout(new FlowLayout()); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#125;void init() &#123; text1=new JTextArea(6,8); text2=new JTextArea(6,8); add(new JScrollPane(text1)); add(new JScrollPane(text2)); text1.getDocument().addDocumentListener(this); //像文档注册监视器 &#125;@Overridepublic void changedUpdate(DocumentEvent e) &#123; String s1=text1.getText(); String regex=\"[\\\\s\\\\d\\\\p&#123;Punct&#125;]+\"; //空格类字符、0~9、标点符号其中一个出现1次或n次 String[] word=s1.split(regex); Arrays.sort(word); //将字典从小到大排序 text2.setText(null); for(String s:word) text2.append(s);&#125;@Overridepublic void insertUpdate(DocumentEvent e) &#123; changedUpdate(e);&#125;@Overridepublic void removeUpdate(DocumentEvent e) &#123; changedUpdate(e);&#125;&#125; 4.MouseEvent事件(鼠标)getX() getY() 获取鼠标在事件源上的x-y坐标 getClickCount() 获取鼠标单击次数 getModifiers() 获取鼠标的左键或右键,使用InputEvent类中的常量BUTTON1_MASK与BUTTON3_MASK表示 1.mousePressed(MouseEvent) 在事件源上按下鼠标 2.mouseReleased(MouseEvent) 在事件源上释放鼠标 3.mouseEntered(MouseEvent) 鼠标进入组件时 4.mouseExited(MouseEvent) 鼠标离开容器时 5.mouseClicked(MouseEvent) 单击鼠标时 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.util.Arrays;public class Action extends JFrame implements MouseListener&#123;JTextField text;JTextArea area;JButton button;public Action() &#123; init(); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#125;void init() &#123; setLayout(new FlowLayout()); text=new JTextField(8); area=new JTextArea(55,138); text.addMouseListener(this); button=new JButton(\"按钮\"); button.addMouseListener(this); addMouseListener(this); add(button); add(text); add(new JScrollPane(area));&#125;@Overridepublic void mouseClicked(MouseEvent e) &#123; if(e.getClickCount()&gt;=2) area.append(\"\\n鼠标连击，位置：\"+\"(\"+e.getX()+\",\"+e.getY()+\")\");&#125;@Overridepublic void mouseEntered(MouseEvent e) &#123; if(e.getSource() instanceof JButton) //instanceof属于 area.append(\"\\n鼠标进入按钮，位置：\"+\"(\"+e.getX()+\",\"+e.getY()+\")\"); if(e.getSource() instanceof JTextField) area.append(\"\\n鼠标进入文本框，位置：\"+\"(\"+e.getX()+\",\"+e.getY()+\")\"); if(e.getSource() instanceof JFrame) area.append(\"\\n鼠标进入窗口，位置：\"+\"(\"+e.getX()+\",\"+e.getY()+\")\");&#125;@Overridepublic void mouseExited(MouseEvent e) &#123; area.append(\"\\n鼠标退出，位置：\"+\"(\"+e.getX()+\",\"+e.getY()+\")\"); &#125;@Overridepublic void mousePressed(MouseEvent e) &#123; area.append(\"\\n鼠标按下，位置：\"+\"(\"+e.getX()+\",\"+e.getY()+\")\");&#125;@Overridepublic void mouseReleased(MouseEvent e) &#123; area.append(\"\\n鼠标释放，位置：\"+\"(\"+e.getX()+\",\"+e.getY()+\")\"); &#125;&#125; mouseDragged(MouseEvent) 拖动鼠标(不必在事件源上) mouseMoved(MouseEvent) 移动鼠标(在事件源上) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.awt.*;import java.awt.event.*;import javax.swing.*;public class PoliceListen extends JLayeredPane implements MouseListener,MouseMotionListener&#123; JButton button=new JButton(\"用鼠标拖动我\"); int x,y,a,b,x0,y0; //x,y鼠标在组件中的位置,a,b组件左上角在容器的位置 PoliceListen()&#123; JButton button=new JButton(\"用鼠标拖动我\"); button.addMouseListener(this); button.addMouseMotionListener(this); setLayout(new FlowLayout()); add(button,JLayeredPane.DEFAULT_LAYER); //默认层 &#125; public void mouseDragged(MouseEvent e) &#123; Component com=null; if(e.getSource() instanceof Component) &#123; com=(Component) e.getSource(); a=com.getBounds().x; b=com.getBounds().y; x=e.getX();y=e.getY(); a=a+x; b=b+y; com.setLocation(a-x0, b-y0); &#125; &#125; public void mouseMoved(MouseEvent e) &#123; &#125; public void mouseClicked(MouseEvent e) &#123;&#125; public void mouseEntered(MouseEvent e) &#123;&#125; public void mouseExited(MouseEvent e) &#123;&#125; public void mousePressed(MouseEvent e) &#123; JComponent com=null; //定义组件容器 com=(JComponent) e.getSource(); //放入事件源 setLayer(com,JLayeredPane.DRAG_LAYER); //点击进入拖拽层 a=com.getBounds().x; b=com.getBounds().y; x0=e.getX(); y0=e.getY(); &#125; public void mouseReleased(MouseEvent e) &#123; JComponent com=null; com=(JComponent) e.getSource(); setLayer(com,JLayeredPane.DEFAULT_LAYER); &#125;&#125; //释放 返回默认层import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.util.Arrays;public class Action extends JFrame&#123; PoliceListen listen;public Action() &#123; listen=new PoliceListen(); add(listen,BorderLayout.CENTER); setVisible(true); setBounds(12,12,300,300); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#125;&#125;public class Test &#123; public static void main(String[] args) &#123;Action win=new Action(); win.setBounds(10, 10, 460, 360); win.setTitle(\"拖动\");&#125;&#125; 5.焦点事件(FocusEvent)当点击一个组件时，该组件就有输入焦点，其他就没有，一个组件时可以调用public boolean requestFocusInWindow()方法获得输入焦点 添加监视器：addFocusListener() 方法：1.focusGained(FocusEvent e) 从无输入焦点到有输入焦点 ​ 2.focusLost(FocusEvent e)从有输入焦点到无输入焦点 6.键盘事件(KeyEvent)KeyPressed(KeyEvent e) 按下 KeyReleased(KeyEvent e) 释放 KeyTyped(KeyEvent e) 按下又释放 getKeyCode() 获取键码值 getKeyChar 获取键盘字符 12345678910111213141516171819202122232425262728293031323334353637383940414243import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.util.Arrays;public class Action extends JFrame implements KeyListener,FocusListener&#123; JTextField text[]=new JTextField[3]; JButton button; Action()&#123; setLayout(new FlowLayout()); for(int i=0;i&lt;3;i++) &#123;text[i]=new JTextField(7); text[i].addKeyListener(this); text[i].addFocusListener(this); add(text[i]); &#125; button=new JButton(\"确定\"); add(button); text[0].requestFocusInWindow(); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void focusGained(FocusEvent e) &#123; JTextField t=(JTextField) e.getSource(); t.setText(null); &#125; public void focusLost(FocusEvent e) &#123; &#125; public void keyPressed(KeyEvent e) &#123; JTextField t=(JTextField) e.getSource(); if(t.getCaretPosition()&gt;=6) //获取插入的字符数 t.transferFocus(); //转移焦点 &#125; public void keyReleased(KeyEvent e) &#123; &#125; public void keyTyped(KeyEvent e) &#123; &#125;&#125; 5.使用MVA结构模型、视图、控制器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class PoliceListen&#123; double a,b,c,area; public void set1(double e) &#123; a=e; &#125; public void set2(double e) &#123; b=e; &#125; public void set3(double e) &#123; c=e; &#125;public String getarea() &#123; if(a+b&gt;c&amp;&amp;a+c&gt;b&amp;&amp;b+c&gt;a) &#123; double p=(a+b+c)/2.0; area=Math.sqrt(p*(p-a)*(p-b)*(p-c)); return String.valueOf(area);&#125; else &#123;return \"不是三角形\";&#125;&#125; &#125;import javax.swing.*;import java.awt.*;import java.awt.event.*;public class Action extends JFrame implements ActionListener&#123; PoliceListen listen; JTextField text1,text2,text3; JTextArea area; //提供视图 JButton button=new JButton(); double a,b,c;public Action() &#123; init(); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;void init() &#123; listen=new PoliceListen(); text1=new JTextField(5); text2=new JTextField(5); text3=new JTextField(5); area=new JTextArea(); button=new JButton(\"计算面积\"); JPanel panel=new JPanel(); panel.add(new JLabel(\"边A\")); panel.add(text1); panel.add(new JLabel(\"边B\")); panel.add(text2); panel.add(new JLabel(\"边C\")); panel.add(text3); panel.add(button); button.addActionListener(this); add(panel,BorderLayout.NORTH); add(new JScrollPane(area),BorderLayout.CENTER);&#125;@Overridepublic void actionPerformed(ActionEvent e) &#123; try&#123;a=Double.parseDouble(text1.getText().trim()); //...... b=Double.parseDouble(text2.getText().trim()); c=Double.parseDouble(text3.getText().trim()); listen.set1(a); listen.set2(b); listen.set3(c); String max=listen.getarea(); area.append(\"三角形\"+a+\",\"+b+\",\"+c+\"的面积：\"); area.append(max+\"\\n\");&#125; catch(Exception ex) &#123; area.append(\"\\n\"+ex+\"\\n\"); &#125;&#125;&#125;public class Test &#123; public static void main(String[] args) &#123;Action win=new Action(); win.setBounds(10, 10, 460, 360); win.setTitle(\"三角形\");&#125;&#125; 6.对话框（JDialog）有点多。。。假期再写 有模式：弹出对话框后堵塞其他线程的执行 无模式：不堵塞 1.消息对话框 1234567891011121314151617181920212223242526272829import javax.swing.*;import java.awt.*;import java.awt.event.*;public class Action extends JFrame implements ActionListener&#123; JTextField text; JTextArea area; String regex=\"[a-zA-Z]+\";public Action() &#123; text=new JTextField(22); text.addActionListener(this); area=new JTextArea(); add(text,BorderLayout.NORTH); add(area,BorderLayout.CENTER); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;@Overridepublic void actionPerformed(ActionEvent e) &#123; if(e.getSource()==text) &#123; String str=text.getText(); if(str.matches(regex)) &#123; area.append(str+\",\"); &#125; else &#123; JOptionPane.showMessageDialog(this, \"输入错误\",\"警告\",JOptionPane.WARNING_MESSAGE); text.setText(null); &#125; &#125;&#125;&#125; 2.输入对话框 123456789101112131415161718192021222324252627282930313233343536373839import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.util.*;public class Action extends JFrame implements ActionListener&#123; JButton button; JTextArea area;public Action() &#123; button=new JButton(\"弹出\"); area=new JTextArea(); add(button,BorderLayout.NORTH); add(new JScrollPane(area),BorderLayout.CENTER); button.addActionListener(this); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;@Overridepublic void actionPerformed(ActionEvent e) &#123; String str=JOptionPane.showInputDialog(this, \"输入数字，用空格分隔\",\"输入对话框\",JOptionPane.PLAIN_MESSAGE); //showInputDialog if(str!=null) &#123; Scanner scanner=new Scanner(str); double sum=0; int k=0; while(scanner.hasNext()) &#123; try &#123; double number=scanner.nextDouble(); if(k==0) area.append(\" \"+number); else area.append(\"+\"+number); sum=sum+number; k++;&#125; catch(InputMismatchException exp) &#123; String t=scanner.next(); &#125; &#125; area.append(\"=\"+sum+\"\\n\"); &#125;&#125;&#125; 3.确认对话框 JOptionPane.YES_ON_OPTION JOptionPane.YES_ON_CANCEL_OPTION JOptionPane.OK_CANCEL_OPTION 1234567891011121314151617181920212223242526272829303132333435import javax.swing.*;import java.awt.*;import java.awt.event.*;public class Action extends JFrame implements WindowListener&#123;public Action() &#123; setVisible(true); setDefaultCloseOperation(JFrame.DEFAULT_CURSOR); this.addWindowListener(this); &#125;@Overridepublic void windowActivated(WindowEvent e) &#123;&#125;@Overridepublic void windowClosed(WindowEvent e) &#123;&#125;@Overridepublic void windowClosing(WindowEvent e) &#123; int a=JOptionPane.showConfirmDialog(null, \"你确定？？\",\"关闭\",JOptionPane.YES_NO_OPTION); if(a==JOptionPane.YES_OPTION) System.exit(-1);&#125;@Overridepublic void windowDeactivated(WindowEvent e) &#123; &#125;@Overridepublic void windowDeiconified(WindowEvent e) &#123;&#125;@Overridepublic void windowIconified(WindowEvent e) &#123;&#125;@Overridepublic void windowOpened(WindowEvent e) &#123; &#125;&#125; 4.颜色对话框 5.文件对话框 6.自定义对话框 7.发布GUI程序可以直接用eclipse打包jar.然后用exe4j转换exe。wo它🦄 步骤： 1.先找到写的java后缀源文件 d 2.将源文件编码为后缀为class的源文件(cmd中用javac A.java指令，A为类名) 3.编写后缀为mf的清单文件，格式如下： 4.使用cmd生成jar文件 c表示生成新的jar文件，f表示生成jar的名称(Tom.jar)，m表示文件清单的名字(Mymoon.mf)，后跟源文件，*表示该目录下的所有文件。 另：java -jar A.jar可以解压,也可以直接解压软件解压。 public class Test { // 默认60秒后关机 public void shutdown() { // 关机 try { Runtime.getRuntime().exec(&quot;shutdown /s /t 60&quot;); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } // 根据输入的时间秒数关机 public void shutdown(String s) { try { // 关机 Runtime.getRuntime().exec(&quot;shutdown /s /t &quot; + s); //关机时间可以自动设置 } catch (IOException e) { e.printStackTrace(); } }————————————————版权声明：本文为CSDN博主「sarida」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/sarida/java/article/details/81195378","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://2544165563.github.io/tags/JAVA/"}]},{"title":"requests爬取数据","slug":"Python爬虫","date":"2020-08-27T03:00:50.637Z","updated":"2020-09-23T15:14:33.846Z","comments":true,"path":"2020/08/27/Python爬虫/","link":"","permalink":"http://2544165563.github.io/2020/08/27/Python%E7%88%AC%E8%99%AB/","excerpt":"","text":"requests的使用先来一个例子看一下使用过程1234567&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(\"http://www.baidu.com\")&gt;&gt;&gt; r.status_code200 #状态码，200表明成功&gt;&gt;&gt; r.encoding = 'utf-8'&gt;&gt;&gt; r.text'&lt;!DOCTYPE html&gt;\\r\\n&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; 方法主要方法，也就用到get。 12345678910111213requests.request() #构造一个请求，支撑一下各种方法requests.get() #获取HTML网页requests.head() #获取HTML网页头信息requests.post() #不改变原数据添加新数据requests.put() #覆盖原数据添加数据requests.patch() #局部修改请求requests.delete() #删除请求 可用request()来执行其他方法，也可以直接用其他requests库的方法 1requests.request(method,url,**kwargs) 第一个参数 1234r &#x3D; requests.request(&#39;GET&#39;,url,**kwargs)#参数&#39;GET&#39; &#39;HEAD&#39; &#39;POST&#39; &#39;PUT&#39; &#39;PATCH&#39; &#39;PUT&#39; &#39;POST&#39; &#39;delete&#39; &#39;OPTIONS&#39; 第二个参数就是网址，直接看第三个参数 12345678910111213141516171819202122232425262728r &#x3D; requests.request(method,url,params&#x3D;kv)#参数(其余主要方法适用)params:字典或字节序列，作为参数增加到返回的url中 data:字典、字节序列或文件对象，提交数据 json:JSON格式的数据，提交使用 headers:字典，HTTP定制头 cookies:字典或CookieJar,Request中的cookie auth:元组 files:字典类型，传输文件timeout:设定超时时间，秒为单位proxies:字典类型，设定访问代理服务器，可以增加登录认证allow_redirects:重定向,默认Truestream:获取内容立即下载，默认Trueverify:认证SSL证书开关，默认Truecert:本地SSL证书路径 get()方法后，处理数据的一些方法，不加括号哟~~ 1234567891011121314151617r = requests.get(url,params=None,**kwargs) #get构造向服务器请求资源的Request对象#requests返回包含服务器资源的Response对象r.status_code #Http请求的返回状态，200表示连接成功，404表示失败r.text #响应内容的字符串形式，url对应的页面内容r.encoding #在HTTP header中猜测的响应内容编码方式r.apparent_encoding #从内容分析出编码方式r.content #响应内容的二进制形式r.raise_for_ataus() #当状态不是200时，引起HTTPError异常r.header # post()与put()方法的使用 12345678r = post(url,data=None,json=None,**kwargs)r = put(url,data=None,**kwargs)payload = &#123;'key1':'value1','key2':'value2'&#125;r = requests.post('http://httpbin.org/post',data = payload)r.text 异常1234567891011requests.ConnectionError #网络连接错误异常requests.HTTPError #HTTP错误异常requests.URLRequired #URL缺失异常requests.TooManyRedirects #超过最大重定向次数，产生重定向异常requests.ConnectTimeout #连接远程服务器超时异常requests.Timeout #请求URL超时，产生超时异常 代码框架12345678910import requestsdef getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return \"产生异常\" Robots协议User-agent: * Disallow: / 对于所有用户，不允许爬取任何数据 爬虫被拒绝123456&gt;&gt;&gt; r = requests.get(\"https://www.amazon.cn/\")&gt;&gt;&gt; r.status_code503&gt;&gt;&gt; r.encoding='utf-8'&gt;&gt;&gt; r.text抱歉，我们只是想确认一下当前访问者并非自动程序。为了达到最佳效果，请确保您浏览器上的 Cookie 已启用。 不让用爬虫爬取，就只能伪装了。 1234&gt;&gt; kv = &#123;'user-agent':'Mozilla/5.0'&#125;&gt;&gt; r = requests.get(\"http://www.baidu.com\",headers = kv)&gt;&gt; r.status_code200 这样就可以让网站认为我们不是爬虫强盗，而是一个浏览器良民 爬取搜索结果先附上关键词接口 12百度：http:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;keyword360：http:&#x2F;&#x2F;www.so.com&#x2F;s?q&#x3D;keyword 接下来是代码 123&gt;&gt;&gt; import requests&gt;&gt;&gt; kv = &#123;'wd':'Python'&#125;&gt;&gt;&gt; r = requests.get(\"http://www.baidu.com/s\",params = kv) 图片爬取1234567891011import requestsurl = \"http://img0.dili360.com/pic/2020/07/13/5f0bc0add82ed2q84362951.jpg\"path = \"D://test.jpg\"try: r = requests.get(url) with open(path,'wb') as f: f.write(r.content) #将r转换为二进制形式 f.close() print(\"文件保存成功\")except: print(\"爬取失败\") 例 淘宝爬取可能教程太老了，淘宝应该让菜鸡不能轻易爬到物品数据了，下面代码只能看看其中的一些问题了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsimport re def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return \"\" def parsePage(ilt, html): try: plt = re.findall(r'\\\"view_price\\\"\\:\\\"[\\d\\.]*\\\"',html) tlt = re.findall(r'\\\"raw_title\\\"\\:\\\".*?\\\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price , title]) except: print(\"\") def printGoodsList(ilt): tplt = \"&#123;:4&#125;\\t&#123;:8&#125;\\t&#123;:16&#125;\" print(tplt.format(\"序号\", \"价格\", \"商品名称\")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = '书包' u='https://s.taobao.com/search?q=' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: #url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(u) print(html) parsePage(infoList, html) except: continue printGoodsList(infoList) main()","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://2544165563.github.io/tags/python/"}]},{"title":"python基础中的基础...","slug":"python","date":"2020-08-27T03:00:50.634Z","updated":"2020-10-06T15:29:16.231Z","comments":true,"path":"2020/08/27/python/","link":"","permalink":"http://2544165563.github.io/2020/08/27/python/","excerpt":"","text":"例 温度转换字符串”123456”由第一个字符开始记序号: ​ 0,1,2,3,4,5 ​ -6,-5,-4,-3,-2,-1 123456789TempStr = input(\"请输入带有符号的温度值:\")if TempStr[-1] in ['F','f']: # -1代表字符串最后一位 C =(eval(TempStr[0:-1]) - 32)/1.8 #eval去除字符串最外层 print(\"转换后的温度是&#123;:.2f&#125;C\".format(C))elif TempStr[-1] in ['C','c']: F=1.8*eval(TempStr[0:-1]) + 32 print(\"转换后的温度是&#123;:.2f&#125;F\".format(F))else: print(\"输入格式错误\") 数学计算浮点数的运算在计算的时候由于二进制的转换导致存在不确定尾数,可用round求值 1round(0.1+0.2,1) #对计算保留1位小数 浮点数的表示 132e-2 #相当于0.32 其他一些运算函数1234567891011121314151617181920212223abs(x) #取绝对值divmod(10，3) #商余，结果为(3,1)pow(x,y[,z]) #x**y%z,其中z可以省略round(x[,d]) #d可省略，默认值为0max(x1,x2,..,xn)min(x1,x2,..,xn)int(x) #转换为整数float(x) #转换为浮点数complex(x) #转换为复数，xomplex(4)==4+0ja**b # a的b次方a/b # a除以b的浮点数a//b # a除以b的整数 例 天天向上123456789101112def dayUP(df): dayup=1 for i in range(365): if i%7 in [6,0]: dayup = dayup*(1 - 0.01) else: dayup = dayup*(1 + df) return dayupdayfactor = 0.01while dayUP(dayfactor) &lt; 37.78: dayfactor +=0.001print(\"工作日的努利参数是&#123;:.3f&#125;\".format(dayfactor)) 字符串字符串的定义123456str = '123'str = \"123\"str = \"\"\"123 123\"\"\" 字符串的使用12345678910111213141516#索引&lt;字符串&gt;[M] #第M+1个字符#切片&lt;字符串&gt;[M:N:K] #M:开头 N:结尾 K:步长#逆序&lt;字符串&gt;[::-1]#转义符\\\"使用双引号\\\"了。\" #使用双引号\"了。#\\b回退 \\n换行 \\r回车(回到本行的行首) 字符串操作符12345x + y #连接字符串n*x #复制字符串n次x in s #判断x是否为s的子串，返回False与True 字符串处理函数123456789len(x) #返回字符串长度str(x) #将x转换为字符串hex(x) oct(x) #转换为十六进制或八进制的字符串chr(u) #将Unicode编码转换为对应字符ord(x) #将字符转换为Unicode编码 字符串处理方法123456789101112131415str.lower() #全小写str.upper() #全大写str.split(s) #拆分，\"A,B,C\".split(\",\")==['A','B','C']str.count(sub) #返回子串sub在str中出现的次数str.replace(old,new) #将old替换成newstr.center(width[,fillchar]) #\"liu\".center(9,\"=\") == '===liu==='str.strip(chars) #\"= python=\".strip(\" =np\") == \"ytho\"str.join(iter) #\",\".join(\"123\") == \"1,2,3\" 字符串类型的格式化12345678910111213141516171819202122232425262728293031# 槽\"&#123;&#125;是一个&#123;&#125;\".format(\"chenlvtang\",\"小天才\") ==\"&#123;1&#125;是一个&#123;0&#125;\".format(\"小天才\",\"chenlvtang\")#槽内部对格式化的配置方式&#123;&lt;参数序号&gt;:&lt;格式控制标记&gt;&#125;: &lt;填充&gt; &lt;对齐&gt; &lt;宽度&gt; &lt;,&gt; &lt;.精度&gt; &lt;类型&gt; 对齐#&lt;左对齐，&gt;右对齐，^居中 类型#b二进制,c字符,d十进制,o八进制,x十六进制,X大写十六进制,小e科学计数法,大E科学计数法,f,%以百分式 \"0:=^9\".format(\"liu\")=='===liu===' \"0:,.2f\".format(\"12345.6789\")=='12,345.68' # %占位符print('我的名字叫%s' %'小飞侠')%s%d 十进制%o 八进制%X 十六进制# f'string'meng='梦'print(f'我的&#123;meng&#125;') 装饰器1234567891011121314151617import timedef cal_time(fn): def inner1(): start1 = time.time() fn() end1 = time.time() print('代码耗时',end1 - start1) return inner1@cal_time # 1.调用cal_time 2.将demo传给fn 3.将inner1返回给demodef demo(): print('Hellow') time.sleep(3) print('ByeBye')demo() # 此时的demo其实是inner 较高级点的用法，在开放封闭原则下修改代码。 在不修改play_game的情况下增加对时间的判断。 123456789101112131415def can_game(fn): def inner1(name,*args,**kwargs): clock1 = kwargs.get('clock1',23) if clock1 &gt; 22 or clock1 &lt; 6: print('不能打游戏') else: fn(name) return inner1@can_gamedef play_game(name): print('&#123;&#125;在玩游戏'.format(name))play_game('李四',clock1 = 22)play_game('张三') 分支结构if、else、elif12345678910111213#and与 or或 not非guess = eval(input())if guess == 520 or guess ==521: print(\"猜对了\")elif guess == 500: print(\"很接近了\")else : print(\"猜错了\") #紧凑形式 &lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;print(\"猜对了\") if guess ==520 else print(\"猜错了\")print(\"猜&#123;&#125;了\".format(\"对\" if guess == 520 else \"错\")) 程序异常处理123456789101112131415try: abc = eval(input()) print(abc)except: #except &lt;异常类型&gt; 来针对处理某类异常 print(\"程序异常\") try: &lt;语句块1&gt;except: &lt;语句块2&gt;else: #语句1运行的化才运行 &lt;语句块3&gt;finally: &lt;语句块4&gt; #一定运行 for循环123456789101112131415161718192021222324252627282930313233#数字for i in range(4): print(i)#0 \\n 1 \\n 2 \\n 3 \\n for i in range(1,4): print(i)#1 \\n 2 \\n 3 \\nfor i in rang(1,6,2): print(i)#1 \\n 3 \\n 5 \\n#字符串for str in \"Hellow\": print(str,end=\",\")#H,e,l,l,o,w,#列表for item in enumerate([123,\"python\",456]): print(item,end=\",\")#123,python,456#文件for line in fi: print(line)#遍历每一行 while循环123456789101112while a&gt;0: a = a-1 print(a) while not gameOver(a,b): if(x&gt;a): a++ else: b++def gameOver(a,b): return a==15 or b==15 循环搭配else123456for c in \"python\": if c == \"t\": continue #break时，else不运行 print(c,end=\"\")else: #只有当循环中执行break时，该语句才不执行 print(\"正常退出\") 例 圆周率计算1234567pi = 0N = 100for k in range(N) : pi += 1/pow(16,k)*( \\ 4/(8*k+1)-2/(8*k+4) - \\ 1/(8*k+5) - 1/(8*k+6))print(\"圆周率值是:&#123;&#125;\".format(pi)) 函数的定义12345678910111213141516171819def fact(n,m=1): #n为非可选参数，m为可选参数，调用时m可有可无 s = 1 for i in range(1, n+1): s *= i return s//m#fact(10) == 10!//1 fact(10,2) == 10!//2def fact(n,m=1): s = 1 for i in range(1, n+1): s *= i return s//m,n,m#赋值a,b,c = fact(10,5) == (725760,10,5)def fact(n, *args, **kwargs): # b为可变参数，填几个都行 print(n,args,kwargs)#fact(1,2,3,a=4,b=5) == 1 (2,3) &#123;'a':4,'b':5&#125; lambda紧凑函数少用 1234567&lt;函数名&gt; = lambda &lt;参数&gt; : &lt;表达式&gt; #紧凑函数f = lambda x,y : x + y# f(1,2) == 3f = lambda : \"Hellow\"# print(f()) = Hellow 多用 1234def abc(x,y,lam): a = lam(x,y) print(a)abc(1,2,lambda a,b:a+b) 对含有字典的列表排序 123456test = [ &#123;'name':'LiMing','age':18&#125;, &#123;'name':'WangLei','age':10&#125;]test.sort(key=lambda x:x['age']) # 传递给key的必须是函数print(test) # [&#123;'name': 'WangLei', 'age': 10&#125;, &#123;'name': 'LiMing', 'age': 18&#125;] filter过滤1234567891011test = [1,2,3,4,5]x = filter(lambda ls : ls &gt; 3,test)# x为可迭代对象# 输出方法1for i in x: print(i)# 输出方法2ls1 = list(x)print(ls1) map改动元素123test = [1,2,3,4,5]x = map(lambda ls : ls + 2,test)print(list(x)) reduce相加1234567from functools import reducetest = [ &#123;'name':'LiMing','age':18&#125;, &#123;'name':'WangLei','age':10&#125;, &#123;'name':'MaXiao','age':20&#125;]print(reduce(lambda x, y: x + y['age'], test, 0)) PyInstaller打包程序123456789101112131415#小小程序耽误我一晚，该死。#需要安装pyinstaller第三方库-h #查看帮助--clean #清理打包过程中的临时文件-D,-onedir #默认值，生成dist文件-F,-onefile #在dist文件夹中只生成独立的打包文件-i &lt;图标文件名.ico&gt; #指定打包程序使用的图标文件#小结 #最好都带有-F，生成的pycache与build可删除 #该程序在cmd中运行#例子pyinstaller -i tu.ico -F test.py 组合数据类型集合元素特征：无序、唯一、不可更改 表示：{1,2,3} 创建：{} 或 set()创建可变集合 创建空集合必须用set() ​ frozenset创建不可变集合 例子： 123A=&#123;123,\"abc\",(\"abc\",123)&#125; #&#123;123,'abc',('abc',123)&#125;B=set(\"abca\") #&#123;a,c,b&#125; 无序，相同只有一个 集合操作符123456789S|T#并 S&amp;T#交 S-T#差 S^T#补S&gt;=T...#增强操作符S|=T #对S进行更新... 集合处理方法123456789101112131415161718192021S.add(x)S.update(x) # 将可迭代对象x拆分放入集合S.discard(x) #移除，不存在，不报错S.remove(x) #移除，不存在，报错KeyErrorS.clear() # 清空S.pop() #随机返回一个数并删除，更新S，为空KeyErrorS.copy() #返回S的副本len(S)x in S #True or Falsex not in Sset(x) #转换为集合 例 数据去重123l=[\"p\",\"p\",\"y\",1,2,2]s=set(l) #&#123;'p','y',1,2&#125;l=list(s) #['p','y',1,2] 序列元素特征：有序，不唯一，基类类型，包含字符串类型、元组类型、列表类型 序号规则： 0 1 2 3 4 5 6 ————————&gt; &lt;———————– -7 -6 -5 -4 -3 -2 -1 序列操作符1234567891011x in Sx not in Sx+tn*ss[i] #索引，返回i序号的元素s[i:j:k] #切片 序列处理方法123456789len(s)min(s)max(s)s.index(x) #返回x的位置s.index(x,i,j) #给定范围i~j 元组元素特征：创建后不能修改，继承序列的全部方法 创建：() 或 tuple() 规则：元组的()可有可无 12def fun(): return 0,1 #1,2为元组类型 列表元素特征：创建后可以修改，不唯一，无长度限制 创建：[] 或 list() 12l=[1,2,3]t=l #t与l均指向同一列表 列表操作符1234567891011ls[i]=x #替换ls[i:j:k]=ltdel ls[i] #删除del ls[i:j:k]ls += ltls *= n 列表处理方法1234567891011121314151617181920212223ls.append(x) #ls[i].append(x)用于嵌套列表ls1.extend(ls2) # 连接del ls[0] #删除ls的第一个元素ls,index(values) # 查询元素所在位置ls.clear()ls.copy()ls.insert(i,x)ls.pop(i) #默认返回并删除最后一个元素，取出第i+1个元素ls.remove(x)ls.reverse() #元素顺序反转，覆盖原列表ls.sort(key=len,reverse=True) # 按长度降序排列，直接覆盖原列表sorted(list) # 将列表升序排列，生成一个新列表 字典（映射）字典是键值对的集合，键值对之间无序 创建：{} 或 dict() 1234567&#123;&lt;键1&gt;:&lt;值1&gt;,&lt;键2&gt;:&lt;值2&gt;...&#125;d = dict(1='a',2='b')&lt;值&gt; = &lt;字典变量&gt;[&lt;键&gt;]&lt;字典变量&gt;[&lt;键&gt;] = &lt;值&gt; #用来增加键值对 字典处理方法123456789101112131415161718192021del d[k]k in dd.keys()d.values()d.items() #返回所有d.get(k,&lt;default&gt;) #k不存在则返回default值d.pop(k,&lt;default&gt;) #取出d.popitem() #随机取出，以元组类型返回d1.update(d2) # 连接d.clear()len(d) 例 统计文本单词数量123456789101112131415161718def getText(): txt = open(\"hamlet.txt\",\"r\").read() txt = txt.lower() for ch in '|\"#$%&amp;*+,-./:;&lt;=&gt;?@[\\\\]^_`&#123;|&#125;~': txt = txt.replace(ch,\" \") return txthamletTxt = getText()words = hamletTxt.split()counts = &#123;&#125;for word in words: counts[word] = counts.get(word,0)+1items = list(counts.items())items.sort(key=lambda x:x[1],reverse=True)#lambda指明按key排序，reverse为从大到小for i in range(10): word,count=items[i] print(\"&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;\".format(word,count)) 文件文件的打开与关闭存储状态 与 占用状态 的转换 12345678910111213141516171819202122#打开&lt;变量名&gt; = open(&lt;文件名&gt;,&lt;打开模式&gt;)#文件名在不同目录时用绝对路径#打开模式'r' #只读，不存在返回FileNotFoundErrpr，默认值'w' #覆盖写,不存在就创建，存在就覆盖'x' #创建写，不存在就创建，存在返回FileExistsError'a' #追加写，不存在就创建，存在就在文件内容和继续写'b' #二进制形式打开't' #文本文件形式打开，默认值'+' #与r/w/x/a7一起用，增加读写功能#关闭&lt;变量名&gt;.close() 文件内容的读取12345&lt;f&gt;.read(x) #读取长度为x的信息，x可有可无&lt;f&gt;.readline(x) #读取长度为x的信息，x可有可无&lt;f&gt;.readlines(x) #一行一个字符串，读取前x行，可有可无 文件内容的写入12345&lt;f&gt;.write(s)&lt;f&gt;.writelines(lines) #写入一个字符串列表,字符串之间紧挨&lt;f&gt;.seek(x) #0-文件开头,1-当前位置,2-文件结尾 例 自动绘制123456789101112131415161718192021222324252627282930313233343536import turtle as tt.title('自动轨迹绘制')t.setup(800,600,0,0)t.pencolor(\"red\")t.pensize(5)#数据读取datals = []f = open(\"data.txt\")for line in f: line = line.replace(\"\\n\",\"\") datals.append(list(map(eval,line.split(\",\")))) #map让eval对分节后的每个字符串使用f.close()#自动绘制for i in range(len(datals)): t.pencolor(datals[i][3],datals[i][4],datals[i][5]) t.fd(datals[i][0]) if datals[i][1]: t.right(datals[i][2]) else: t.left(datals[i][2])#数据'''300,0,144,1,0,0300,0,144,0,1,0300,0,144,0,0,1300,0,144,1,1,0300,0,108,0,1,1184,0,72,1,0,1184,0,72,0,0,0184,0,72,0,0,0184,0,72,0,0,0184,1,72,1,0,1184,1,72,0,0,0184,1,72,0,0,0184,1,72,0,0,0184,1,72,0,0,0184,1,720,0,0,0''' re正则表达式使用原生字符串表达，r’text’ old: ‘Hellow’ new: r’Hellow’ 操作符123456789101112131415161718192021222324252627. 任何单个字符[] [a-z]a到z的范围[^ ] 非[^abc]不包括abc* abc*表示ab、abc、abcc等，0次或无限次扩展+ 前一字符1次或无限次扩展? 0次或1次扩展| abc|def，表示abc、def&#123;m&#125; ab&#123;2&#125;c表示abbc&#123;m,n&#125; ab&#123;1,2&#125;c表示abc,abbc^ 开头$ 结尾() 分组，内部只能用|\\d 数字\\w 字母和数字 1[\\u4e00-\\u9fa5] 匹配中文字符 方法12345678910111213re.compile(pattern,flags=0) #将字符串编译成正则表达式对象re.search(pattern,string,flags=0) #找到第一个位置的match对象re.match(pattern,string,flags=0) #在字符串开始位置查找，match对象re.findall(pattern,string,flags=0) #以列表类型返回全部子串re.split(pattern,string,maxsolit=0,flags=0) #分割后列表返回re.finditer(pattern,string,flags=0)#返回迭代类型，都是match对象re.sub(pattern,repl,string,count=0,flags=0) #替换后返回字符串 flags常用标记12345re.I #忽略大小写re.M #将每行当作开始re.S #操作符能匹配所有字符 match对象属性123456789101112131415.string #待匹配文本.re #匹配时的pattern对象.pos #开始位置.endpos #结束位置.group(0) #获取匹配后的字符串.start() #匹配字符的开始位置.end() #匹配字符的结束位置.span() #返回(.start(),.end()) 贪婪匹配与最小匹配1234567&gt;&gt;&gt; rst = re.search(r'PY.*N',\"PYQNPLN\")&gt;&gt;&gt; rst.group()'PYQNPLN'&gt;&gt;&gt; rst = re.search(r'PY.*?N',\"PYQNPLN\")&gt;&gt;&gt; rst.group()'PYQN 只差一个？就是两种不同的匹配 面向对象的用法123456old:rst = re.search(r'[1-9]\\d&#123;5&#125;','BIT 100081')new:pat = re.compile(r'[1-9]\\d&#123;5&#125;')rst = pat.search('BIT 100081') 模块的导入123456789import timefrom random import randint # 导入random模板里的randint函数，调用randint方法时不用加random. 。from math import * # 引入math模板里的全部方法import turtle as t # 为模板设置简称from random import randint as rd # 为方法设置简称 time时间123456789101112131415161718192021222324252627import time#时间获取time.time() #1594889513.965165time.ctime() #'Thu Jul 16 16:52:16 2020'time.gmtime() #time.struct_time(tm_year=2020, tm_mon=7, tm_mday=16, tm_hour=8, tm_min=55, tm_sec=7, tm_wday=3, tm_yday=198, tm_isdst=0)#时间格式化t = time.gmtime()# Y年:2020 m月:7 B月:April b月:Apr d日:16 A星期:Wednesday a星期:Wed H小时(24h):12 I小时(12h):7 p上下午:PM,M分钟:26 S秒:26time.strftime(\"%Y-%m-%d %H:%M:%S\",t) # '2020-07-16 09:00:44'timeStr='2020-07-16 17:13:20'time.strptime(timeStr,\"%Y-%m-%d %H:%M:%S\") #time.struct_time(tm_year=2020, tm_mon=7, tm_mday=16, tm_hour=17, tm_min=13, tm_sec=20, tm_wday=3, tm_yday=198, tm_isdst=-1)#程序计时time.perf_counter() #定义start与end，然后相减计算。time.sleep(3.3) #3.3秒后退出 例 文本进度条1234567891011scale = 50print(\"执行开始\".center(scale//2,\"-\"))start = time.perf_counter()for i in range(scale+1): a='*'*i b='.'*(scale-i) c=(i/scale)*100 dur = time.perf_counter() - start print(\"\\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s\".format(c,a,b,dur),end=\"\") #end使输出后不换行，\\r回到行首 time.sleep(0.1)print(\"\\n\"+\"执行结束\".center(scale//2,\"-\")) 例 七段数码管绘制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import turtleimport timedef drawGap(): turtle.penup() turtle.fd(5)def drawLine(draw): drawGap() turtle.pendown() if draw else turtle.penup() turtle.fd(40) drawGap() turtle.right(90)def drawDigit(digit): drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False) drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,2,6,8] else drawLine(False) turtle.left(90) drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False) drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False) turtle.left(180) turtle.penup() turtle.fd(20)def drawDate(date): turtle.pencolor(\"red\") for i in date: if i=='-': turtle.write('年',font=(\"Arial\",18,\"normal\")) turtle.pencolor(\"green\") turtle.fd(40) elif i=='=': turtle.write('月',font=(\"Arial\",18,\"normal\")) turtle.pencolor(\"blue\") turtle.fd(40) elif i=='+': turtle.write('日',font=(\"Arial\",18,\"normal\")) else: drawDigit(eval(i))def main(): turtle.setup(800,350,200,200) turtle.penup() turtle.fd(-300) turtle.pensize(5) drawDate(time.strftime('%Y-%m=%d+',time.gmtime())) turtle.hideturtle() turtle.done()main() random随机数123456789101112131415161718192021#基本随机函数import random #伪随机数。。。。随机都是骗人的，你就是那1%的倒霉蛋random.seed(10) #产生种子10对应的序列#相同种子随机数的顺序相同，默认种子是系统时间random.random() #产生[0.0,1.0)之间的随机小数#扩展随机数函数random.randint(a,b) #产生[a,b]之间的一个整数，这不挺有用的吗random.randrange(m,n[,k]) #在[m,n)之间产生以k为增长的随机整数random.getrandbits(k) #生成一个k比特长的随机整数random.uniform(a,b) #生成[a,b]之间的随机小数random.choice([1,2,4,5]) #随机选取其中一个数random.shuffle([1,2,3,4]) #返回打乱后的序列,比如[3,2,4,1] 例 计算圆周率12345678910111213from random import randomfrom time import perf_counterdarts = 1000*1000hits = 0.0start = perf_counter()for i in range(1,darts+1): x,y = random(),random() dist = pow(x**2+y**2,0.5) if dist &lt;=1.0: hits = hits+1pi = 4*(hits/darts)print(\"圆周率值是:&#123;&#125;\".format(pi))print(\"运行时间是:&#123;:.5f&#125;s\".format(perf_counter()-start)) turtle画图1234567891011121314151617181920import turtle as tt.setup(w,h,x,y) #设置位置大小t.screensize(800,600,'green') # 设置画布t.speed(30) # 设置绘制速度，[1，10]t.hideturtle() # 隐藏画笔，showturtle显示画笔t.dot(20,'red') # 画一个实心原点t.fillcolor('red')t.begin_fill() # 开始填充t.circle(100,360)t.end_fill() # 结束填充t.penup() t.pendown() t.fd(-250) t.pensize(25) #设置笔迹的宽度t.pencolor(\"green\")t.seth(90) #让海龟转向90°的位置for 1 in rang(4): #循环4次 t.circle(40,80) #40的半径绘制80°的弧线 t.circle(-40,80)t.done() #可以不会自动退出 例 科赫雪花（使用递归）123456789101112131415161718192021#递归要包括 基例 与 递归链条import turtle as tdef koch(size,n): if n == 0: #基例 t.fd(size) else: for angle in [0,60,-120,60]: #递归链条 t.left(angle) koch(size/3,n-1)def main(): t.setup(800,400) t.penup() t.goto(-300,-50) t.pendown() t.pensize(2) for i in range(3): koch(120,3) t.right(120) t.hideturtlemain() jieba中文分词()12345678910jieba.lcut(s) #精确模式，无冗余#中国是一个伟大的国家&gt;&gt;&#123;'中国','是','一个','伟大','的','国家'&#125;jieba.lcut(s,cut_all=True) #全模式，有冗余#中国是一个伟大的国家&gt;&gt;&#123;'中国','国是','一个','伟大','的','国家'&#125;jieba.lcut_for)serch(s) #搜索引擎模式#中华人民共和国&gt;&gt;&#123;'中华','华人','人民','共和','共和国'&#125;jieba.add_word(w) #向分词词典中增加新词w wordcloud词云12345678910111213141516171819202122232425262728293031323334import wordcloud步骤1w = wordcloud.WordCloud()#w=wordcloud.WprdCloud(width=100) #配置对象参数widthheightmin_font_sizemax_font_sizefont_step #字号的步进间隔font_path #指定字体文件路径，微软雅黑：msyh.ttcmax_wordsstop_words=&#123;\"123\"&#125; #排除的单词maskfrom scipy.misc import imreadmk=imread(\"pic.png\")w=wordcloud.WordCloud(mask=mk)backgorund_color步骤2w.generate(txt) #加载文本步骤3w.to_file(filename) #输出图片文件,png或jpg 例 文本文件生成词云12345678910111213141516171819202122import jiebaimport wordcloudfrom imageio import imreadmask = imread(\"fivestart.png\")f = open(\"中国特色社会主义.txt\",\"r\",encoding=\"utf-8\")t = f.read()f.close()ls = jieba.lcut(t)txt = \" \".join(ls)w = wordcloud.WordCloud(font_path=\"msyh.ttc\",background_color=\"white\",mask = mask)w.generate(txt)w.to_file(\"text.png\")import jiebaimport wordcloudf = open(\"中国特色社会主义.txt\",\"r\",encoding=\"utf-8\")t = f.read()f.close()ls = jieba.lcut(t)txt = \" \".join(ls)w = wordcloud.WordCloud(font_path=\"msyh.ttc\",\\ background_color=\"white\")w.generate(txt)w.to_file(\"text.png\") json字符串1234567891011import jsontest = &#123;'1':'a','2':'b','3':'c'&#125;x = json.dumps(test) # 转换为json字符串print(x)# x == '&#123;\"1\":\"a\",\"2\":\"b\",\"3\":\"c\"&#125;'x1 = json.loads(x) # 转换为原来的类型print(x1)# x1 == &#123;'1':'a','2':'b','3':'c'&#125; os库123456789import osos.system(\"命令\")os.cpu_dount()os.getlogin()#其余对文件的路径不太感兴趣。。。用到的时候再看吧 第三方库的安装pip install &lt;&gt; 安装 pip install -U &lt;&gt; 更新 pip uninstall &lt;&gt; 卸载 pip download &lt;&gt; 下载不安装 pip show &lt;&gt; 查看详情信息 pip search &lt;&gt; 搜索 pip list &lt;&gt; 将安装的列举出来","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://2544165563.github.io/tags/python/"}]},{"title":"JDBC数据库连接","slug":"JDBC数据库连接","date":"2020-08-27T03:00:50.629Z","updated":"2020-08-01T02:06:20.575Z","comments":true,"path":"2020/08/27/JDBC数据库连接/","link":"","permalink":"http://2544165563.github.io/2020/08/27/JDBC%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/","excerpt":"1.连接MySQL数据库及操作","text":"1.连接MySQL数据库及操作 123456789101112131415161718192021222324252627import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class Test &#123; public static void main(String[] args) &#123;//加载驱动类，并执行该类中的初始化代码，将驱动注册到DriverManager中 try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); System.out.println(\"加载数据库驱动成功\");&#125; catch (ClassNotFoundException e) &#123; System.out.println(\"加载数据库驱动失败\");&#125; try &#123; //数据库的路径 String url=\"jdbc:mysql://localhost:3306/date\"; //数据库的用户名 String user=\"root\"; //密码 String password=\"liuxiang5.\"; Connection con=DriverManager.getConnection(url,user,password); System.out.println(\"连接数据库成功\"); &#125; catch (SQLException e) &#123; System.out.println(\"连接数据库失败\");&#125;&#125;&#125; 在大佬的帮助下终于连接上了🐇 解决方法链接 （https://blog.csdn.net/qq_41950447/article/details/90085170） 2.查询select* from 表名 1234567891011121314151617181920212223 try&#123;//向数据库发送SQL查询语句 Statement st=con.createStatement();//执行查询 String sql=\"select * from form1 where salary&gt;1900\"; ResultSet rs=st.executeQuery(sql); //处理结果 while(rs.next()) &#123; String number=rs.getString(1); String name=rs.getString(2); Date birthday=rs.getDate(\"birthday\"); double salary=rs.getDouble(4); System.out.println(number+\" \"+name+\" \"+birthday+\" \"+salary); &#125; rs.close(); //关闭结果集 con.close(); //关闭连接 &#125; catch (Exception e) &#123; System.out.println(\"数据库操作异常\"+e); &#125; finally &#123; System.out.println(\"数据库数据获取成功\"); &#125; 3.增加、删除、修改1.更新记录的SQL语法 UPDATE &lt;表名&gt; SET &lt;字段名&gt; = 新值 WHERE &lt;条件子句&gt; 12345sql=\"update form1 set salary=5000 where name='小明'\";pst=con.prepareStatement(sql);int m=pst.executeUpdate();if(m!=0) &#123; System.out.println(\"更新了\"+m+\"条记录\"); 2.添加记录的SQL语法 ​ INSERT INTO 表(字段列表) VALUES(对应的具体的记录) 或 INSERT INTO 表 VALUES(对应的具体的记录) 12345sql=\"insert into form1 values('004','小明','2005-11-29','3000')\"; PreparedStatement pst=con.prepareStatement(sql); int m=pst.executeUpdate(); if(m!=0) &#123; System.out.println(\"对标添加了\"+m+\"条记录\"); 3.删除记录的SQL语法 DELETE FROM &lt;表名&gt; WHERE &lt;条件子句&gt; 12345 sql=\"delete from form1 where number='005'\";pst=con.prepareStatement(sql);int m=pst.executeUpdate();if(m!=0) &#123; System.out.println(\"删除了\"+m+\"条记录\"); 4.通配符123456 sql=\"delete from form1 where salary=?\";pst=con.prepareStatement(sql);pst.setDouble(1, 5000);int m=pst.executeUpdate();if(m!=0) &#123; System.out.println(\"删除了\"+m+\"条记录\");","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://2544165563.github.io/tags/JAVA/"}]},{"title":"I/O流","slug":"IO流","date":"2020-08-27T03:00:50.626Z","updated":"2020-07-15T06:55:51.039Z","comments":true,"path":"2020/08/27/IO流/","link":"","permalink":"http://2544165563.github.io/2020/08/27/IO%E6%B5%81/","excerpt":"1.File类","text":"1.File类 常用方法：boolean exists() 判断对应文件或目录是否存在 ​ boolean delete() boolean createNewFile() ​ String getName() String getParent () ​ String getPath() String getAbsolutePath() ​ boolean canRead() boolean canWrite() ​ boolean isFile() boolean isDirectory() ​ boolean isAbsolute() long lastModified() ​ long length() String []list() ​ File[] listFiles() 实例： 123456789101112import java.io.*;public class And &#123; public static void main(String[] args) throws IOException &#123; File fi=new File(\"D:\\\\JAVA测试\",\"test.txt\"); if(fi.exists()) &#123; System.out.println(fi.getName()); System.out.println(fi.length()); System.out.println(fi.canRead());&#125; else fi.createNewFile(); &#125;&#125; 运行可执行文件12345678910import java.io.*;public class Jydge &#123; public static void main(String[] args) &#123; Runtime c=Runtime.getRuntime(); File f=new File(\"文件地址\",\"文件名\"); try &#123; c.exec(f.getAbsolutePath());&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125;&#125; 2.文件字节流123456789101112131415161718192021import java.io.*;public class And &#123; public static void main(String[] args) throws IOException, InterruptedException &#123;//建立文件链接 File f1=new File(\"D:\\\\JAVA测试\",\"test.txt\"); File f2=new File(\"D:\\\\JAVA测试\",\"test1.txt\");//选择流 FileInputStream in=new FileInputStream(f1); FileOutputStream out=new FileOutputStream(f2);//拷贝 byte b[]=new byte[1024]; int len=0; while((len=in.read())!=-1) &#123; out.write(b,0,len); &#125; out.flush(); //将缓存区域的内容读取到文件当中（不理解）。。//释放资源 out.close(); in.close(); //先打开的后关闭 &#125;&#125; 3.文件字符流123456789101112131415161718192021import java.io.*;public class And &#123; public static void main(String[] args) throws IOException&#123;//建立文件链接 File f1=new File(\"D:\\\\JAVA测试\",\"test.txt\"); File f2=new File(\"D:\\\\JAVA测试\",\"test1.txt\");//选择流 FileReader in=new FileReader(f1); FileWriter out=new FileWriter(f2);//拷贝 char[] b=new char[1024]; int len=0; while((len=in.read())!=-1) &#123; out.write(b, 0, len); &#125; out.flush(); //将缓存区域的内容读取到文件当中（不理解）。。//释放资源 out.close(); in.close(); //先打开的后关闭 &#125;&#125; 4.缓冲流可以使字符串数组中的元素换行写入文本，也可以让文本中不同行的元素读取时在同一行 12345678910111213141516171819202122import java.io.*;public class Jydge &#123; public static void main(String[] args) throws IOException &#123; File file=new File(\"C:\\\\Users\\\\asus\\\\Desktop\\\\我滴东西\\\\456.txt\"); String content[]= &#123;\"张三\",\"李四\",\"王五\"&#125;; FileWriter out1=new FileWriter(file); BufferedWriter out2=new BufferedWriter(out1); for(String str:content) &#123; out2.write(str); out2.newLine();&#125; out2.close(); out1.close(); FileReader in1=new FileReader(file); BufferedReader in2=new BufferedReader(in1); int len=0; String s=null; while((s=in2.readLine())!=null) System.out.print(s); in1.close(); in2.close();&#125;&#125; 5.随机流 类型 字节 Byte 1 Int 4 long 8 Char 2 Float 4 Double 8 12345678910111213import java.io.*;public class Jydge &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile inAndOut=new RandomAccessFile(\"C:\\\\Users\\\\asus\\\\Desktop\\\\我滴东西\\\\456.txt\",\"rw\"); char data[]= &#123;'i','l','o','v','e','y','o','u'&#125;; for(int i=0;i&lt;data.length;i++) //写入 inAndOut.writeChar(data[i]); for(long i=0;i&lt;data.length;i++) &#123; //读取 inAndOut.seek(i*2); //定位读写位置，根据元素类型调整数字 System.out.print(inAndOut.readChar()+\" \"); &#125; inAndOut.close();&#125;&#125; readLine（） 读取一个文本行，第二次读取下一行解决非ASCII字符乱码问题（比如汉字） 12345678910import java.io.*;public class Jydge &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile inAndOut=new RandomAccessFile(\"C:\\\\Users\\\\asus\\\\Desktop\\\\我滴东西\\\\456.txt\",\"rw\"); String str=inAndOut.readLine(); byte[] b=str.getBytes(\"iso-8859-1\"); //将获取的字符串重新编码 String content=new String(b); System.out.println(content); inAndOut.close();&#125;&#125; 鸽了鸽了，后面内容有点多，等放假再弄（懒癌发作，数据结构还一点没学T.T）","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://2544165563.github.io/tags/JAVA/"}]},{"title":"HTML基础（部分CSS）","slug":"html","date":"2020-08-27T03:00:50.623Z","updated":"2020-08-01T02:27:48.481Z","comments":true,"path":"2020/08/27/html/","link":"","permalink":"http://2544165563.github.io/2020/08/27/html/","excerpt":"标签类型","text":"标签类型 1234&lt;h1&gt;~&lt;h6&gt; &lt;/h1&gt;~&lt;/h6&gt; 标题&lt;p&gt;&lt;/p&gt; 内容&lt;pre&gt;&lt;/pre&gt; 可以拥有空格&lt;div&gt;&lt;/div&gt; 容器 换行1&lt;br/&gt; 居中1&lt;h1 align=\"center\"&gt;居中&lt;/h1&gt; 引入图片1&lt;img src=\"图片地址\" width=\"宽度\" height=\"长度\" alt=\"加载失败\"/&gt; 引入链接1&lt;a href=\"链接地址\"&gt;&lt;/a&gt; 更改颜色12&lt;p style=\"color:red\"&gt;&lt;/p&gt;&lt;p style=\"background-color:red\"&gt;&lt;/p&gt; 隐藏标题1231.&lt;dfn title=\"法外狂徒 性别：男 年龄：20\"&gt;张三&lt;/dfn&gt;2.&lt;acronym title=\"liuxiang\"&gt;LX&lt;/acronym&gt;3.&lt;abbr title=\"liuxiang\"&gt;LX&lt;/abbr&gt; 字体类型1&lt;p style=\"font-family:verdana;font-size:20px\"&gt;字体&lt;/p&gt; 区域跳跃12&lt;h1 id=\"top\"&gt;&lt;/h1&gt;&lt;a href=\"#top\"&gt;&lt;/a&gt; 反向输出1&lt;bdo dir=\"rtl\"&gt;liu xiang&lt;/bdo&gt; 划线12&lt;del&gt;中划线&lt;/del&gt;&lt;ins&gt;下划线&lt;/ins&gt; 列表12345678910111.无序&lt;ul&gt; &lt;li&gt;l&lt;/li&gt; &lt;li&gt;love&lt;/li&gt; &lt;li&gt;you&lt;/li&gt;&lt;/ul&gt;2.有序&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 输入框1&lt;form action=\"传输地址\"&gt;&lt;input type=\"text\" required placeholder=\"输入框提示\"&gt;&lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt; &lt;!--required为必填--&gt; 选择12345678910111.单选&lt;form action=\"传输地址\"&gt; &lt;label for=\"a\" type=\"radio\" name=\"a-b\" checked&gt;a&lt;/label&gt; &lt;label for=\"b\" type=\"radio\" name=\"a-b\"&gt;b&lt;/label&gt;&lt;/form&gt; &lt;!--checked为默认选项--&gt;2.多选&lt;form action=\"传输地址\"&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"personality\"&gt;A&lt;/label&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"personality\"&gt;B&lt;/label&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"personality\"&gt;C&lt;/label&gt;&lt;/form&gt; 添加边框css12345678&lt;style&gt; .border&#123; border-color: green; border-width: 10px; border-style: solid; border-radius:50%;&#125;&lt;/style&gt;&lt;p class=\"border\"&gt;&lt;img src=\"图片地址\"/&gt;&lt;/p&gt; 内边距css123&lt;style&gt; .padding&#123;padding-top:10px;padding-right:10px;padding:left;padding-bottom:10px;&#125;&lt;/style&gt; 外边距css123&lt;style&gt; .margin&#123;margin-top:10px; margin-left:-25px;&#125;&lt;/style&gt;","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://2544165563.github.io/tags/HTML/"}]},{"title":"BeautifulSoup提取数据","slug":"BeautifulSoup提取数据","date":"2020-08-27T03:00:50.621Z","updated":"2020-08-11T11:36:59.267Z","comments":true,"path":"2020/08/27/BeautifulSoup提取数据/","link":"","permalink":"http://2544165563.github.io/2020/08/27/BeautifulSoup%E6%8F%90%E5%8F%96%E6%95%B0%E6%8D%AE/","excerpt":"","text":"BeautifulSoup的使用先来个例子123456789101112131415&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(\"https://python123.io/ws/demo.html\")&gt;&gt;&gt; demo = r.text&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; soup = BeautifulSoup(demo,\"html.parser\")&gt;&gt;&gt; print(soup.prettify())&lt;html&gt; &lt;head&gt; &lt;title&gt; This is a python demo page &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"&gt; #省略....... 主要部分12345&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; soup = BeautifulSoup(demo,\"html.parser\") #html.parser解析器&gt;&gt;&gt; print(soup.prettify()) 其他解析器1234567html.parser #安装bs4lxml #pip install lxmlxml #pip install xmlhtml5lib #pip install html5lib 标签信息获取12345678910111213141516soup = BeautifulSoup(demo,\"html.parser\")&gt;&gt;&gt; soup.title&lt;title&gt;...&lt;/title&gt;&gt;&gt;&gt; soup.a.name'a'&gt;&gt;&gt; soup.a.attrs #查看标签属性&#123;'href': '//www.icourse163.org', 'target': '_top'&#125;&gt;&gt;&gt; soup.a.attrs['href']'//www.icourse163.org'&gt;&gt;&gt; soup.title.string'\\nPython语言程序设计_北京理工大学_中国大学MOOC(慕课)\\n' 遍历12345678&gt;&gt;&gt; newsoup.contents#儿子标签&gt;&gt;&gt; for i in newsoup.children#子标签&gt;&gt;&gt; for i in newsoup.descendants#子孙标签 12345&gt;&gt;&gt; soup.a.parent.name'p' #a的外层标签&gt;&gt;&gt; for i in soup.a.parent.parents#循环遍历先辈标签 1234567891011&gt;&gt;&gt; soup.next_sibling#返回文本顺序的下一个平行结点标签&gt;&gt;&gt; soup.previous_sibling#返回上一个&gt;&gt;&gt; for i in soup.next_sibling#对应迭代类型&gt;&gt;&gt; for i in soup.previous_siblings#对应迭代类型 HTML内容查找soup() == soup.find_all() 12345&lt;&gt;.find_all(name,attrs,recursive,string,**kwargs)attrs:标签属性recursive:是否对子孙全部检索,默认为Ture 12345678910111213for link in soup.find_all('a'): print(link.get('href'))soup.find_all([a,b,c]) #查找多项for tags in soup.find_all(Ture): print(tags,name) #打印所有标签名 import re #查找包含a的标签soup.find_all(re.compile('a'))&gt;&gt;&gt; soup.find_all(string = re.compile(\"chenlvtang\"))['chenlvtang的小房间'] 例 大学排名1234567891011121314151617181920212223242526272829303132333435import requestsfrom bs4 import BeautifulSoupimport bs4import redef getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return \"\"def fillUnivList(ulist,html): soup = BeautifulSoup(html,\"html.parser\") for tr in soup.find('tbody').children: if isinstance(tr,bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string,tds[1].string,tds[4].string])def printUnivList(ulist,num): tplt = \"&#123;0:^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:^10&#125;\" print(tplt.format(\"排名\",\"学校\",\"总分\",chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0],u[1],u[2],chr(12288)))def main(): uinfo = [] url = 'http://www.zuihaodaxue.com/zuihaodaxuepaiming2020.html' html = getHTMLText(url) fillUnivList(uinfo,html) printUnivList(uinfo,20)main()","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://2544165563.github.io/tags/python/"}]},{"title":"树先生","slug":"Hellow树先生","date":"2020-08-27T03:00:50.621Z","updated":"2020-07-15T06:55:43.374Z","comments":true,"path":"2020/08/27/Hellow树先生/","link":"","permalink":"http://2544165563.github.io/2020/08/27/Hellow%E6%A0%91%E5%85%88%E7%94%9F/","excerpt":"1.树","text":"1.树 基本术语： 1.结点：数据元素及分支 2.结点的度：拥有的分支数 3.树的度：等于最大的结点度 4.叶子：没有分支的结点 5.非终端结点：度不为0，除根结点外，也称内部结点 6.双亲和孩子 7.祖先：包括双亲 8.子孙：包括孩子 9.层次 10.兄弟：同一个双亲 11.堂兄弟：双亲不同但在同一层次 12.深度：最大层次 13.有序树和无序树 14.森林：多棵树 树的三种常用表示法（懒了，遇到的时候再去看）： （1）双亲表示法 （2）孩子表示法 （3）孩子兄弟法 （二叉树表示法、二叉链表表示法） 2.二叉树（与树是两种类型）二叉树定义：（1）最多有两个结点 （2）有左右之分，不能调换 普通二叉树性质：1.叶的数量m只与度为2的结点有关，n为度为2结点数量，则m=n+1。 ​ 2.第i层上至多有2的i-1次方个结点。 ​ 3.深度为k，最多有2的k次方减1个结点。 特殊二叉树定义：（1）满二叉树：除叶结点外，度都为2. （2）完全二叉树：与满二叉树的顺序对应。（挨个排的树） 完全二叉树性质：1.具有n个结点，深度为[log2n]+1。 ​ 2.对于结点i，其双亲为i/2,左孩子为2i,又孩子为2i+1。 遍历二叉树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef char DataType;typedef struct BiTNode&#123; DataType data; struct BiTNode *lchild,*rchild;&#125;BiTNode,*BiTree; void Create_BiTree(BiTree *T)&#123; char ch; ch=getchar(); if(ch=='@') *T=NULL; else&#123; *T=(BiTree)malloc(sizeof(BiTNode)); (*T)-&gt;data=ch; Create_BiTree(&amp;(*T)-&gt;lchild); Create_BiTree(&amp;(*T)-&gt;rchild);&#125; &#125;//先序void PreOrderTraverse (BiTree T)&#123; printf(\"%c\",T-&gt;data); if(T-&gt;lchild) PreOrderTraverse(T-&gt;lchild); if(T-&gt;rchild) PreOrderTraverse(T-&gt;rchild);&#125;//中序void InOrderTraverse (BiTree T)&#123; if(T-&gt;lchild) PreOrderTraverse(T-&gt;lchild); printf(\"%c\",T-&gt;data); if(T-&gt;rchild) PreOrderTraverse(T-&gt;rchild);&#125;//后序void PostOrderTraverse(BiTree T)&#123; if(T-&gt;lchild) PreOrderTraverse(T-&gt;lchild); if(T-&gt;rchild) PreOrderTraverse(T-&gt;rchild); printf(\"%c\",T-&gt;data);&#125;int main(int argc, char *argv[]) &#123; BiTree T;printf(\"\\n 输入叶结点的信息（建立空二叉树输入@）: \"); Create_BiTree(&amp;T); printf(\"\\n\");printf(\"\\n 前序遍历结果: \");PreOrderTraverse(T);printf(\"\\n 中序遍历结果: \");InOrderTraverse (T);printf(\"\\n 后序遍历结果: \");PostOrderTraverse(T);printf(\"\\n\");&#125; 线索二叉树1234567891011121314151617typedef char TElemType;typedef struct BiThrNode&#123; TElemType data; struct BiThrNode *lchild,*rchild; //没有孩子结点则标签等于1 int LTag,RTag; //等于0时指向孩子结点，等于1时指向前驱或后继&#125;BiThrNode,*BiThrTree;//中序线索化void Inthread(BiTree root)&#123; if(root!=NULL)&#123; Inthread(root-&gt;lchild); if(root-&gt;lchild==NULL) &#123;root-&gt;LTag=1;root-&gt;lchild=pre;&#125; if(pre!=NULL&amp;&amp;pre-&gt;rchild==NULL) &#123;pre-&gt;rchild=root;pre-&gt;RTag=1;&#125; pre=root; Inthread(root-&gt;rchild); &#125;&#125; （1）线索：指向前驱或后继的指针 （2）线索化：在遍历过程中修改空链域 3.森林、树1.树转二叉树 （1）连接相邻兄弟结点（2）只保留之前与第一个孩子的连线 2.二叉树还原树或森林 （1）若某结点为其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子。。。都与该结点的双亲相连 （2）删除原有所有右孩子的连线 3.森林转二叉树 （1）将每一棵树转换为二叉树 （2）将二叉树的根结点作为前一个二叉树根结点的右孩子连接。 4.树和森林的遍历树的遍历：（1）先根遍历ABECFHGD（2）后根遍历EBHFGCDA 森林的遍历（1）先序（2）中序（3）后序 5.哈夫曼树当有n个叶子时，就有2n-1个结点 基本术语： 1.路径：两个结点间的分支构成。 2.路径长度：路径上的分支数目 3.树的路径长度：树根到每一个结点的路径长度之和 4.权：分为结点权和边权。 5.结点的带权路径长度：路径长度*该结点的权值 6.树的带权路径长度：所有叶子到树根的带权路径长度之和。 7.哈夫曼树：树的带权路径长度最小的二叉树。 哈夫曼树的构造方法（1）给定n个权值，每个权值构成只有根结点的森林 （2）将权值最小的两棵树分别当做左右孩子合并成一棵，新的权值为两棵树权值的和。 （3）重复2步骤。 6.哈夫曼编码（最短，最优）前缀码：在一个编码系统中，任何一个编码不是其他编码的前缀。 哈夫曼码：左为1，右为0. 编码方式： （1）定长编码：根据出现的情况m次，求2的n次方 &lt;=m。 求出n ​ （2）哈夫曼编码：建立哈夫曼树，根据哈夫曼树编码 问题实例： 编码过程： 鸽了，过两天根据指导再打吧🐷","categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://2544165563.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"http://2544165563.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"日常","slug":"日常","permalink":"http://2544165563.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"python","slug":"python","permalink":"http://2544165563.github.io/tags/python/"},{"name":"mysql","slug":"mysql","permalink":"http://2544165563.github.io/tags/mysql/"},{"name":"Linux","slug":"Linux","permalink":"http://2544165563.github.io/tags/Linux/"},{"name":"高数","slug":"高数","permalink":"http://2544165563.github.io/tags/%E9%AB%98%E6%95%B0/"},{"name":"JAVA","slug":"JAVA","permalink":"http://2544165563.github.io/tags/JAVA/"},{"name":"HTML","slug":"HTML","permalink":"http://2544165563.github.io/tags/HTML/"},{"name":"数据结构","slug":"数据结构","permalink":"http://2544165563.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}